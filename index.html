<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>IMSE780</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    div.csl-bib-body { }
    div.csl-entry {
      clear: both;
    }
    .hanging div.csl-entry {
      margin-left:2em;
      text-indent:-2em;
    }
    div.csl-left-margin {
      min-width:2em;
      float:left;
    }
    div.csl-right-inline {
      margin-left:2em;
      padding-left:1em;
    }
    div.csl-indent {
      margin-left: 2em;
    }
  </style>
  <script>
      let baseLps = {
          prototypeLp: {
              xMin: -1,
              xMax: 8.99,
              yMin: -1,
              yMax: 10.99,
              obj: [3, 5],
              ineqs: [[3, 2, 18, "l"], [1, 0, 4, "l"], [0, 2, 12, "l"]],
              ineqTextPlaces: [[5, 2.5], [2.25, 8], [6, 6.9]]
          }
      }
      const drawPlot = (svg, svgId) => {
          svg.id = svgId;
          const parentDiv = document.createElement('div');
          svg.parentNode.insertBefore(parentDiv, svg);
          parentDiv.appendChild(svg);
          svgDefs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
          svg.appendChild(svgDefs);
          goodDirColor = 'blue';
          badDirColor = 'red';
          goodArrowheadMarker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
          goodArrowheadMarker.id = goodDirColor + 'ArrowMarker';
          goodArrowheadMarker.setAttribute('markerWidth', 5);
          goodArrowheadMarker.setAttribute('markerHeight', 3);
          goodArrowheadMarker.setAttribute('refX', 0);
          goodArrowheadMarker.setAttribute('refY', 1.5);
          goodArrowheadMarker.setAttribute('orient', 'auto');
          arrowPoly = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
          arrowPoly.setAttribute('points', "0 0, 5 1.5, 0 3");
          arrowPoly.setAttribute('fill', goodDirColor);
          goodArrowheadMarker.appendChild(arrowPoly);
          badArrowheadMarker = goodArrowheadMarker.cloneNode(true);
          badArrowheadMarker.id = badDirColor + 'ArrowMarker'
          badArrowheadMarker.firstChild.setAttribute('fill', badDirColor);
          arrowheadMarker = goodArrowheadMarker.cloneNode(true);
          arrowheadMarker.id = 'blackArrowMarker'
          arrowheadMarker.firstChild.setAttribute('fill', 'black');
          svgDefs.appendChild(goodArrowheadMarker);
          svgDefs.appendChild(badArrowheadMarker);
          svgDefs.appendChild(arrowheadMarker);
          const args = { ...JSON.parse(JSON.stringify(baseLps))[svg.getAttribute('base')], ...JSON.parse(svg.getAttribute('altargs'))};
          const xMin = args['xMin'];
          const xMax = args['xMax'];
          const yMin = args['yMin'];
          const yMax = args['yMax'];
          const plotExtremePoints = [[0, 0], [xMax, 0], [xMax, yMax], [0, yMax]];
          let obj = args['obj'];
          if (Object.keys(args).includes('altObj')){
              obj = args['altObj'];
          }
          let ineqs = args['ineqs'];
          let ineqTextPlaces = args['ineqTextPlaces'];
          const removeConstraints = args['removeConstraints'] || [];
          const addConstraints = args['addConstraints'] || []
          if (removeConstraints.length > 0) {
              ineqs = ineqs.filter((x, i) => !removeConstraints.includes(i));
              ineqTextPlaces = ineqTextPlaces.filter((x, i) => !removeConstraints.includes(i));
          }
          if (addConstraints.length > 0) {
              for (const addConstr of addConstraints){
                  ineqs.push(addConstr[0]);
                  ineqTextPlaces.push(addConstr[1])
              }
          }
          const allIneqs = ineqs.concat([[1, 0, 0, "g"], [0, 1, 0, "g"]]);
          const altFeasRegionTextPlace = args['altFeasRegionTextPlace']
          const showVertices = args['showVertices'] || false;
          const choosePoints = args['choosePoints'] || false;
          const chooseObjVals = args['chooseObjVals'] || false;
          const simplexStart = args['simplexStart'];
          const extraPoints = args['extraPoints'] || [];
          const extraText = args['extraText'] || [];
          const extraMathText = args['extraMathText'] || [];
          const extraLines = args['extraLines'] || [];
          const extraEqns = args['extraEqns'] || [];
          const x1ObjStr = obj[0] == 0 ? '' : `${obj[0]}x_1`;
          const x2ObjStr = obj[1] == 0 ? '' : `${obj[1]}x_2`;
          const betweenObjStr = obj[0] == 0 ? '' : (obj[1] > 0 ? '+' : '');
          const objStr = x1ObjStr + betweenObjStr + x2ObjStr;
          const w = svg.getAttribute('width');
          const h = svg.getAttribute('height');
          const leq = String.fromCharCode(8804);
          const geq = String.fromCharCode(8805);
          const coordToPix = (xCoord, yCoord) => {
              xPix = w * (xCoord - xMin) / (xMax - xMin);
              yPix = h - h * (yCoord - yMin) / (yMax - yMin);
              return [xPix, yPix]
          }
          const getObjVal = (x, y) => obj[0] * x + obj[1] * y;
          const unitPixToCoordX = (xMax - xMin) / w;
          const unitPixToCoordY = (yMax - yMin) / h;
          svg.style.marginLeft = -Math.abs(1 / unitPixToCoordX) / 2;
          const pixToCoord = (xPix, yPix) => {
              xCoord = xPix * ((xMax - xMin) / w) + xMin;
              yCoord = (yPix - h) * (-(yMax - yMin) / h) + yMin;
              return [xCoord, yCoord]
          }
          const lineBetweenCoords = (x1, y1, x2, y2, attrs) => {
              el = document.createElementNS('http://www.w3.org/2000/svg', 'line');
              const [x1Pix, y1Pix] = coordToPix(x1, y1);
              const [x2Pix, y2Pix] = coordToPix(x2, y2);
              el.setAttribute('x1', x1Pix);
              el.setAttribute('y1', y1Pix);
              el.setAttribute('x2', x2Pix);
              el.setAttribute('y2', y2Pix);
              attrs = attrs || {}
              attrs['style'] = attrs['style'] || 'stroke:black';
              for (const [k, v] of Object.entries(attrs)){
                  el.setAttribute(k, v);
              }
              svg.appendChild(el);
          }
          const addText = (text, x, y, attrs) => {
              txt = document.createElementNS('http://www.w3.org/2000/svg', 'text');
              txt.textContent = text;
              txt.setAttribute('x', x);
              txt.setAttribute('y', y);
              for (const [k, v] of Object.entries(attrs || {})){
                  txt.setAttribute(k, v);
              }
              svg.appendChild(txt);
          }
          const addMathText = (math, x, y, attrs) => {
              attrs = attrs || {};
              forObj = document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject');
              mathEl = document.createElement('span');
              katex.render(math, mathEl, {
                  throwOnError: false
              });
              if (attrs['coordToPix'] || false) {
                  [x, y] = coordToPix(x, y)
              }
              forObj.setAttribute('x', x);
              forObj.setAttribute('y', y);
              attrs['height'] = attrs['height'] || '1.2rem';
              attrs['width'] = attrs['width'] || '15rem';
              attrs['font-size'] = attrs['font-size'] || '12pt';
              attrs['font-family'] = attrs['font-family'] || 'KaTeX_Main,Times New Roman,serif';
              for (const [k, v] of Object.entries(attrs || {})){
                  forObj.setAttribute(k, v);
              }
              forObj.appendChild(mathEl);
              svg.appendChild(forObj);
          }
          const drawIneqs = () => {
              style = 'stroke:#777;padding:5pt';
              let ineqNum = 0;
              for ([xCoef, yCoef, rhs, sense] of ineqs) {
                  ineqNum += 1;
                  const ineqId = svgId + 'ineq' + ineqNum
                  plotEqn(xCoef, yCoef, rhs, {style: style, id: ineqId});
                  let [e1x, e1y, e2x, e2y] = getEqnEndpoints(xCoef, yCoef, rhs);
                  hoverLineId = svgId + 'ineq' + ineqNum + 'hoverLine';
                  lineBetweenCoords(e1x, e1y, e2x, e2y, {'style': 'stroke:black;stroke-width:5;opacity:0', 'id': hoverLineId})
                  const hoverLine = document.getElementById(hoverLineId);
                  polyId = svgId + 'ineq' + ineqNum + 'shaded';
                  ((xCoef, yCoef, rhs, sense, polyId) => {
                      hoverLine.onmouseover = () => {
                          const cornerPoints = plotExtremePoints;
                          let pts = getIntersectionWithPoly(xCoef, yCoef, rhs, cornerPoints, false);
                          const cpts = cornerPoints.filter(cp => ineqSatisfied(...cp, xCoef, yCoef, rhs, sense));
                          const getPtStr = (p) => p[0] + '---' + p[1];
                          const usedPtStrs = pts.map(p => getPtStr(p));
                          skipPts = [];
                          foundFirstCorner = false;
                          lastUsed = pts[pts.length - 1];
                          for (cp of cpts) {
                              cpStr = getPtStr(cp)
                              if (cpStr in usedPtStrs) {
                                  continue
                              }
                              if (foundFirstCorner) {
                                  usedPtStrs.push(cpStr);
                                  pts.push(cp);
                              } else {                            
                                  if (cp[0] == lastUsed[0] || cp[1] == lastUsed[1]) {
                                      foundFirstCorner = true;
                                      usedPtStrs.push(cpStr);
                                      pts.push(cp);
                                  } else {
                                      skipPts.push(cp);
                                  }
                              }
                          }
                          pts = pts.concat(skipPts);
                          polygonFromPoints(pts, {id: polyId, style: 'fill:rgb(212,212,212);fill:rgb(212,212,212,0.5)'});
                      }
                      hoverLine.onmouseout = () => {
                          shadePoly = document.getElementById(polyId)
                          if (!!shadePoly){
                              shadePoly.remove();
                          }
                      }
                  })(xCoef, yCoef, rhs, sense, polyId)
              }
          }
          const plotEqn = (xCoef, yCoef, rhs, attrs) => {
              lineBetweenCoords(...getEqnEndpoints(xCoef, yCoef, rhs), attrs);
          }
          const getEqnEndpoints = (xCoef, yCoef, rhs) => {
              if (xCoef === 0) {
                  return [0, rhs / yCoef, xMax, rhs / yCoef]
              } else if (yCoef === 0) {
                  return [rhs / xCoef, 0, rhs / xCoef, yMax]
              } else {
                  return [0, rhs / yCoef, rhs / xCoef, 0]
              }
          }
          const drawTickMarks = () => {
              xTick = 0
              style = {'font-size': '10pt', 'font-family': 'KaTeX_Main,Times New Roman,serif'}
              while (xTick <= xMax) {
                  if (xTick >= 0) {
                      lineBetweenCoords(xTick, 0, xTick, (yMax - yMin) / 30);
                      [xText, yText] = coordToPix(xTick, -(yMax - yMin) / 30);
                      addText(xTick, xText - 4, yText + 4, style);
                      xTick += 1;
                  }
              }
              yTick = 0
              while (yTick <= yMax) {
                  if (yTick >= 0) {
                      lineBetweenCoords(0, yTick, (xMax - xMin) / 30, yTick);
                      [xText, yText] = coordToPix(-(xMax - xMin) / 30, yTick);
                      addText(yTick, xText - 4, yText + 4, style);
                      yTick += 1;
                  }
              }
          }
          const isFeasible = (x, y, returnViolated=false) => {
              let feasible = true;
              let violated = [];
              for ([xCoef, yCoef, rhs, sense] of allIneqs) {
                  if (!ineqSatisfied(x, y, xCoef, yCoef, rhs, sense)){
                      feasible = false;
                      if (returnViolated) {
                          violated.push([xCoef, yCoef, rhs])
                      } else {                        
                          break
                      }
                  }
              }
              if (returnViolated) {
                  return [feasible, violated];
              }
              return feasible
          }
          const ineqSatisfied = (x, y, xCoef, yCoef, rhs, sense) => {
              if (sense === "l") {
                  return x * xCoef + y * yCoef <= rhs + 0.0001
              } else {
                  return x * xCoef + y * yCoef >= rhs - 0.0001
              }
          }
          const getVertices = (includePlotEdges=false) => {
              let ineqsToUse = allIneqs;
              if (includePlotEdges) {
                  ineqsToUse = ineqsToUse.concat([[1, 0, xMax, 'l'], [0, 1, yMax, 'l']]);
              }
              let intersections = [];
                  for ([i, [xCoef, yCoef, rhs, sense]] of ineqsToUse.entries()) {
                      for ([j, [xCoef1, yCoef1, rhs1, sense1]] of ineqsToUse.entries()){
                          if (j <= i){
                              continue
                          }
                          denom = xCoef * yCoef1 - xCoef1 * yCoef
                          if (denom === 0){
                              continue
                          }
                          num = xCoef * rhs1 - xCoef1 * rhs;
                          yIntersect = num / denom;
                          if (xCoef === 0) {
                              xIntersect = rhs1 / xCoef1;
                          } else {
                              xIntersect = (rhs / xCoef) - (yCoef / xCoef) * num / denom;
                          }
                          if (xIntersect == 0){
                              xIntersect = 0;
                          }
                          if (yIntersect == 0){
                              yIntersect = 0;
                          }
                          intersections.push([xIntersect || 0, yIntersect, i, j]);
                      }
                  }
                  let vertexStrs = [];
                  let vertices = [];
                  for ([x, y, i, j] of intersections) {
                      if (isFeasible(x, y)) {
                          vertices.push([x, y, i, j]);
                      }
                  }
                  orderedVertexIndices = [0];
                  while (orderedVertexIndices.length < vertices.length) {
                      nextIndex = [...vertices.entries()].filter((val, ind) => {
                          if (orderedVertexIndices.includes(ind)) {
                              return false
                          }
                          lastInd = orderedVertexIndices[orderedVertexIndices.length - 1];
                          return (
                              vertices[ind][2] == vertices[lastInd][2] ||
                              vertices[ind][2] == vertices[lastInd][3] ||
                              vertices[ind][3] == vertices[lastInd][2] ||
                              vertices[ind][3] == vertices[lastInd][3]
                          )
                      })[0][0]
                      orderedVertexIndices.push(nextIndex);
                  }
              if (vertices.length === 0) {
                  return []
              }
              return orderedVertexIndices.map(i => vertices[i].slice(0, 2))
          }
          const polygonFromPoints = (points, attrs) => {
              const poly = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
              poly.setAttribute('points', points.map(v => coordToPix(...v)).join(' '));
              for (const [k, v] of Object.entries(attrs || {})){
                  poly.setAttribute(k, v);
              }
              svg.appendChild(poly);
          }
          const shadeFeasibleRegion = () => {
              const verts = getVertices(true);
              if (verts.length === 0){
                  return
              }
              polygonFromPoints(verts, {'style': "fill:#ddd;stroke:black"})
              if (!!altFeasRegionTextPlace) {
                  const [xPix, yPix] = coordToPix(...altFeasRegionTextPlace);
              } else {
                  const xWeighted = verts.map(v => v[0]).reduce((a, b) => a + b) / verts.length;
                  const yWeighted = verts.map(v => v[1]).reduce((a, b) => a + b) / verts.length;
                  const [xPix, yPix] = coordToPix(xWeighted, yWeighted);
              }
              addText("Feasible", xPix - 30, yPix, {'font-size': '12pt'});
              addText("Region", xPix - 30, yPix + 20, {'font-size': '12pt'});
          }
          const placePoint = (x, y, attrs) => {
              circ = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
              const [xPix, yPix] = coordToPix(x, y);
              circ.setAttribute('cx', xPix);
              circ.setAttribute('cy', yPix);
              circ.setAttribute('r', 3.5);
              for (const [k, v] of Object.entries(attrs || {})){
                  circ.setAttribute(k, v);
              }
              svg.appendChild(circ);
          }
          const plotVertices = () => {
              for ([x, y] of vertices) {
                  placePoint(x, y);
              }
          }
          const drawAxes = () => {
              const fontStyle = {'font-size': '12pt', 'font-family': 'KaTeX_Main,Times New Roman,serif'};
              lineBetweenCoords(0, 0, xMax, 0);
              xDiff = 10 * unitPixToCoordX
              yDiff = 4 * unitPixToCoordY
              polygonFromPoints([[xMax, 0], [xMax - xDiff, yDiff], [xMax - xDiff, -yDiff]], {'style': "fill:black;stroke:black"});
              [xLabelPix, yLabelPix] = coordToPix(Math.ceil(xMax) - 0.5, 0);
              addMathText('x_1', xLabelPix, yLabelPix, fontStyle);
              [xLabelPix, yLabelPix] = coordToPix(0, Math.ceil(yMax) - 0.5);
              addMathText('x_2', xLabelPix - 24, yLabelPix - 20, fontStyle);
              lineBetweenCoords(0, 0, 0, yMax);
              xDiff = 4 * unitPixToCoordX
              yDiff = 10 * unitPixToCoordY
              polygonFromPoints([[0, yMax], [xDiff, yMax - yDiff], [-xDiff, yMax - yDiff]], {'style': "fill:black;stroke:black"});
          }
          const labelIneqs = () => {
              for (i in ineqTextPlaces || []) {
                  ineq = ineqs[i];
                  ineqText = ''
                  ineqText += ineq[0] === 0 ? '' : (ineq[0] == 1 ? '' : ineq[0]) + 'x_1'
                  ineqText += ineq[1] === 0 ? '' : (ineqText === '' ? '' : ' + ') + (ineq[1] == 1 ? '' : ineq[1]) + 'x_2'
                  ineqText += ' ' + (ineq[3] === 'l' ? leq : geq) + ' ' + ineq[2];
                  fontStyle = {'font-size': '12pt'}
                  addMathText(ineqText, ...coordToPix(...ineqTextPlaces[i]), fontStyle);
              }
          }
          const getIntersectionWithPoly = (xCoef, yCoef, rhs, points, checkFeas=true) => {
              let intersections = [];
              let intersectionStrs = [];
              for (i=0; i<points.length; i++){
                  const [p1, p2] = points[i];
                  const [q1, q2] = points[(i + 1) % points.length];
                  const m1 = (p2 - q2) / (p1 - q1);
                  const b1 = p2 - m1 * p1;
                  const m2 = -xCoef / yCoef;
                  const b2 = rhs / yCoef;
                  if (m1 === m2) {
                      continue
                  }
                  if (Math.abs(m1) === Infinity) {
                      xIntersect = p1;
                      yIntersect = m2 * xIntersect + b2;
                  } else if (Math.abs(m2) === Infinity) {
                      xIntersect = rhs / xCoef;
                      yIntersect = m1 * xIntersect + b1
                  } else {
                      xIntersect = (b2 - b1) / (m1 - m2);
                      yIntersect = m1 * xIntersect + b1;
                  }
                  xIntersect = Math.round(1000000 * xIntersect) / 1000000;
                  yIntersect = Math.round(1000000 * yIntersect) / 1000000;
                  interStr = xIntersect + '---' + yIntersect;
                  p = [xIntersect, yIntersect]
                  if (!intersectionStrs.includes(interStr) && xIntersect === xIntersect && yIntersect === yIntersect) {
                      if (!checkFeas || isFeasible(...p)) {
                          intersectionStrs.push(interStr);
                          intersections.push(p)
                      }
                  }
              }
              return intersections
          }
          const vertices = getVertices();
          const verticesAndPlotEdges = getVertices(true);
          drawIneqs();
          labelIneqs();
          shadeFeasibleRegion();
          drawTickMarks();
          if (showVertices){
              plotVertices(vertices);
          }
          drawAxes();
          for (pt of extraPoints) {
              placePoint(...pt);
          }
          for (ln of extraLines) {
              lineBetweenCoords(...ln);
          }
          for (tx of extraText) {
              addText(...tx);
          }
          for (tx of extraMathText) {
              addMathText(...tx);
          }
          const gcd = (a, b) => {
              if (!b) {
                  return Math.abs(a);
              }
              return Math.abs(gcd(b, a % b));
          }
          if (choosePoints) {
              const underDiv = document.createElement('div');
              underDiv.classList = ['underPlot']
              parentDiv.appendChild(underDiv);
              const objDiv = document.createElement('div');
              objDiv.classList = ['pointChooseText'];
              underDiv.appendChild(objDiv);
              katex.render(`\\text{Objective: }${objStr}`, objDiv, {throwOnError: false});
              const pointChooseDiv = document.createElement('div');
              pointChooseDiv.classList = ['pointChooseDiv'];
              underDiv.appendChild(pointChooseDiv);
              const input1 = document.createElement('input');
              const label1 = document.createElement('label');
              label1.classList = ['pointChooseLabel']
              katex.render('x_1:', label1, {throwOnError: false});
              const input2 = document.createElement('input');
              const label2 = document.createElement('label');
              label2.classList = ['pointChooseLabel'];
              katex.render('x_2:', label2, {throwOnError: false});
              const textDiv = document.createElement('div');
              textDiv.classList = ['pointChooseText'];
              underDiv.appendChild(textDiv);
              katex.render('\\text{Select values for }x_1\\text{ and }x_2', textDiv, {throwOnError: false})
              for (inputEl of [input1, input2]) {
                  inputEl.setAttribute('type', 'number');
                  inputEl.setAttribute('min', 0);
                  inputEl.classList = ['pointChooseInput'];
              }
              input1.setAttribute('max', Math.floor(xMax));
              input2.setAttribute('max', Math.floor(yMax));  // todo: enforce min/max in onchange function
              const inputChangeFunc = () => {
                  [x1, x2] = [input1.value, input2.value];
                  const lineClass = 'violatedIneq' + svgId;
                  if (x1 == parseFloat(x1) && x2 == parseFloat(x2)){
                      for (violEl of [...document.getElementsByClassName(lineClass)]){
                          violEl.remove();
                      }
                      const pointId = svgId + 'placedPoint';
                      const pointEl = document.getElementById(pointId);
                      if (!!pointEl) {
                          pointEl.remove();
                      }
                      const [feas, violated] = isFeasible(x1, x2, returnViolated=true);
                      const color = feas ? 'black' : 'red';
                      textDiv.innerHTML = '';
                      if (feas) {
                          textDiv.textContent = `(${x1}, ${x2}) is feasible, objective value ${getObjVal(x1, x2)}.`
                      }
                      else {
                          textDiv.textContent = `(${x1}, ${x2}) is infeasible.`
                          for (v of violated) {
                              plotEqn(...v, {'style': 'stroke:red;stroke-width:0', 'class': 'violatedIneq ' + lineClass})
                              // setTimeout(() => {
                              //     for (violEl of [...document.getElementsByClassName(lineClass)]){
                              //         violEl.remove();
                              //     }
                              // }, 800)
                          }
                      }
                      placePoint(input1.value, input2.value, {'id': pointId, 'style': `stroke:${color};fill:${color}`});
                  }
              }
              input1.addEventListener("change", inputChangeFunc);
              input2.addEventListener("change", inputChangeFunc);
              svg.onclick = (e) => {                
                  let rect = svg.getBoundingClientRect();
                  let x = e.clientX - rect.left;
                  let y = e.clientY - rect.top;
                  [xPix, yPix] = pixToCoord(x, y);
                  input1.value = Math.round(10 * xPix) / 10;
                  input2.value = Math.round(10 * yPix) / 10;
                  inputChangeFunc();
              }
              for (el of [label1, input1, label2, input2]) {
                  pointChooseDiv.appendChild(el);
              }
          }
          if (chooseObjVals) {
              const underDiv = document.createElement('div');
              underDiv.classList = ['underPlot']
              parentDiv.appendChild(underDiv);
              const pointChooseDiv = document.createElement('div');
              pointChooseDiv.classList = ['pointChooseDiv'];
              underDiv.appendChild(pointChooseDiv);
              const pointValDiv = document.createElement('div');
              pointValDiv.classList = ['pointChooseDiv'];
              underDiv.appendChild(pointChooseDiv);
              const input = document.createElement('input');
              const label = document.createElement('label');
              label.classList = ['pointChooseLabel'];
              katex.render(`\\text{Plotting objective: }${objStr}=`, label, {throwOnError: false});
              const textDiv = document.createElement('div');
              textDiv.classList = ['pointChooseText'];
              underDiv.appendChild(textDiv);
              textDiv.textContent = 'Select a value to plot an objective line.'
              input.setAttribute('type', 'number');
              input.setAttribute('min', 0);
              maxObjVal = 0;
              for (extreme of plotExtremePoints) {
                  exObjVal = getObjVal(...extreme);
                  if (exObjVal > maxObjVal) {
                      maxObjVal = exObjVal;
                  }
              }
              input.setAttribute('max', maxObjVal);
              input.classList = ['pointChooseInput'];
              const inputChangeFunc = () => {
                  z = input.value;
                  if (z == parseFloat(z)){
                      eqnId = svgId + 'objEqn';
                      eqnEl = document.getElementById(eqnId);
                      if (!!eqnEl) {
                          eqnEl.remove();
                      }
                      plotEqn(...obj, z, {id: eqnId});
                      const intersectPoints = getIntersectionWithPoly(...obj, z, verticesAndPlotEdges);
                      const intersectLineId = svgId + 'objLineIntersect';
                      intersectLine = document.getElementById(intersectLineId);
                      if (!!intersectLine) {
                          intersectLine.remove();
                      }
                      if (intersectPoints.length === 0) {
                          textDiv.textContent = 'No feasible solutions with objective value ' + z;
                      } else if (intersectPoints.length === 1) {
                          textDiv.textContent = `Single feasible solution (${intersectPoints[0]}) with objective value ${z}`;
                          placePoint(...intersectPoints[0], {'style': 'fill:purple', 'id': intersectLineId})
                      } else {
                          textDiv.textContent = `Multiple feasible solutions have objective value ${z}`;
                          lineBetweenCoords(...intersectPoints[0], ...intersectPoints[1], {'style': 'stroke:purple;stroke-width:2pt', 'id': intersectLineId});
                      }
                  }
              }
              input.addEventListener("change", inputChangeFunc);
              svg.onclick = (e) => {                
                  let rect = svg.getBoundingClientRect();
                  let x = e.clientX - rect.left;
                  let y = e.clientY - rect.top;
                  let z = getObjVal(...pixToCoord(x, y));
                  input.value = Math.round(10 * z) / 10;
                  inputChangeFunc();
              }
              for (el of [label, input]) {
                  pointChooseDiv.appendChild(el);
              }
          }
          if (simplexStart) {
              let nextPoint = simplexStart;
              let pointHistory = [];
              const underDiv = document.createElement('div');
              underDiv.classList = ['underPlot']
              parentDiv.appendChild(underDiv);
              const objDiv = document.createElement('div');
              objDiv.classList = ['pointChooseText'];
              underDiv.appendChild(objDiv);
              katex.render(`\\text{Objective: }${objStr}`, objDiv, {throwOnError: false});
              const currentPlaceText = document.createElement('div');
              currentPlaceText.classList = ['pointChooseText'];
              const possibleDirections = document.createElement('div');
              possibleDirections.classList = ['pointChooseText'];
              const status = document.createElement('div');
              status.classList = ['pointChooseText'];
              const buttonsDiv = document.createElement('div');
              buttonsDiv.classList = ['pointChooseText'];
              const backButton = document.createElement('button');
              backButton.textContent = '<<'
              const resetButton = document.createElement('button');
              resetButton.textContent = 'Reset'
              const forwardButton = document.createElement('button');
              forwardButton.textContent = '>>'
              buttonsDiv.appendChild(backButton);
              buttonsDiv.appendChild(resetButton);
              buttonsDiv.appendChild(forwardButton);
              underDiv.appendChild(currentPlaceText);
              underDiv.appendChild(possibleDirections);
              underDiv.appendChild(buttonsDiv);
              underDiv.appendChild(status);
              const simplexPointId = svgId + 'SimplexPoint';
              const getArrowClass = () => svgId + 'SimplexArrowDir';
              const getArrowIdFromCheckId = (checkId) => checkId + 'TargetArrow';
              const changePoint = () => {
                  currentPoint = pointHistory.length === 0 ? simplexStart : pointHistory[pointHistory.length - 1];
                  simplexPointEl = document.getElementById(simplexPointId);
                  if (!!simplexPointEl) {
                      simplexPointEl.remove();
                      for (arrowEl of [...document.getElementsByClassName(getArrowClass())]){
                          arrowEl.remove();
                      }
                  }
                  katex.render(
                      `\\text{Current solution: }(${currentPoint[0]}, ${currentPoint[1]}),\\text{ objective }${getObjVal(...currentPoint)}`,
                      currentPlaceText
                  );
                  const vertInd = vertices.map((x, i) => i).filter(i => {
                      return vertices[i][0] === currentPoint[0] && vertices[i][1] === currentPoint[1]
                  })[0];
                  adjacents = [vertInd - 1, vertInd + 1].map(i => {
                      return vertices[(i + vertices.length) % vertices.length]    
                  });
                  adjDir = adjacents.map(adj => {
                      dir = [adj[0] - currentPoint[0], adj[1] - currentPoint[1]];
                      dirGcd = gcd(...dir);
                      return [dir[0] / dirGcd, dir[1] / dirGcd];
                  });
                  possibleDirections.innerHTML = '';
                  possibleDirections.textContent = 'Adjacent solution directions:'
                  const tab = document.createElement('table');
                  tab.classList = ['simplexDirectionTable'];
                  const dirHead = document.createElement('th');
                  dirHead.textContent = 'Direction';
                  const objHead = document.createElement('th');
                  objHead.innerHTML = '&Delta; Obj / Unit';
                  const useDir = document.createElement('th');
                  useDir.innerHTML = 'Use?';
                  tab.appendChild(dirHead);
                  tab.appendChild(objHead);
                  tab.appendChild(useDir);
                  possibleDirections.appendChild(tab);
                  dirGains = [];
                  const getCheckId = i => simplexPointId + 'DirCheck' + i
                  for ([i, adj] of adjDir.entries()) {
                      const tr = document.createElement('tr');
                      tab.appendChild(tr);
                      const dirTd = document.createElement('td');
                      dirTd.textContent = `(${adj[0]}, ${adj[1]})`;
                      adjDirNorm = Math.sqrt(adj[0] ** 2 + adj[1] ** 2);
                      unitObjGain = getObjVal(...adj) / adjDirNorm;
                      const arrowHeadCoord = adj.map((ad, iAd) => currentPoint[iAd] + 45 * unitPixToCoordX * ad / adjDirNorm);
                      const plotColor = unitObjGain > 0 ? goodDirColor : badDirColor;
                      attrs = {
                          'style': 'stroke-width:2pt;stroke:' + plotColor,
                          'marker-end': `url(#${plotColor}ArrowMarker)`,
                          'class': getArrowClass(),
                          'id': getArrowIdFromCheckId(getCheckId(i))
                      }
                      lineBetweenCoords(...currentPoint, ...arrowHeadCoord, attrs);
                      dirGains.push(unitObjGain);
                      const objTd = document.createElement('td');
                      objTd.textContent = Math.round(100 * unitObjGain) / 100;
                      const useTd = document.createElement('td');
                      const useInput = document.createElement('input');
                      useInput.id = getCheckId(i);
                      useInput.setAttribute('type', 'checkbox');
                      useInput.onchange = (e) => {
                          for (inputInd = 0; inputInd < adjacents.length; inputInd++){
                              inEl = document.getElementById(getCheckId(inputInd));
                              if (inEl !== e.target){
                                  inEl.checked = false;
                                  document.getElementById(getArrowIdFromCheckId(inEl.id)).classList.remove('simplexArrowChosen');
                              } else {
                                  if (e.target.checked) {
                                      nextPoint = adjacents[inputInd];
                                      document.getElementById(getArrowIdFromCheckId(e.target.id)).classList.add('simplexArrowChosen');
                                  } else {
                                      nextPoint = undefined;
                                      document.getElementById(getArrowIdFromCheckId(e.target.id)).classList.remove('simplexArrowChosen');
                                  }   
                              }                            
                              buttonStatusChange();
                          }
                      }
                      if (unitObjGain <= 0){
                          useInput.disabled = true;
                          tr.style.color = 'red';
                      }
                      useTd.appendChild(useInput);
                      tr.appendChild(dirTd);
                      tr.appendChild(objTd);
                      tr.appendChild(useTd);
                  }                
                  placePoint(...currentPoint, {'id': simplexPointId, 'r': '4.5'});
                  const maxDirGain = Math.max(...dirGains);
                  const numImprovingDirections = dirGains.filter(g => g > 0).length;
                  if (maxDirGain < 0) {
                      status.innerHTML = 'No improving directions, <b>optimal solution found!</b>';
                      nextPoint = undefined;
                  } else {
                      const bestInd = adjacents.map((adj, i) => i).filter(i => dirGains[i] === maxDirGain)[0];
                      const bestDir = adjDir[bestInd];
                      status.textContent = `${numImprovingDirections} improving direction${numImprovingDirections === 1 ? '.' : 's to choose from.'}`;
                      const bestCheck = document.getElementById(getCheckId(bestInd));
                      bestCheck.checked = true;
                      bestCheck.onchange({target: bestCheck});
                      nextPoint = adjacents[bestInd];
                  }
                  buttonStatusChange();
              }
              const buttonStatusChange = () => {                
                  backButton.disabled = pointHistory.length === 0;
                  forwardButton.disabled = !nextPoint;
              }
              forwardButton.onclick = () => {
                  pointHistory.push(nextPoint);
                  changePoint();
              }
              resetButton.onclick = () => {
                  nextPoint = undefined;
                  pointHistory = [];
                  changePoint();
              }          
              backButton.onclick = () => {
                  pointHistory.pop(pointHistory.length - 1);
                  changePoint();
              }
              changePoint();
          }
      }
      const drawAllSvgPlots = () => {
          for ([i, svgEl] of document.querySelectorAll('svg.lpDraw').entries()){
              ((i, svgEl) => {
                  drawPlot(svgEl, 'svg' + i);
              })(i, svgEl)
          }
      }
  </script>
  <script>
      document.onreadystatechange = () => {
          if (document.readyState !== "complete") {
              document.querySelector("#main").style.display = "none";
              document.querySelector(".navbar").style.display = "none";
              document.querySelector("#loader").style.visibility = "visible";
              document.querySelector("#classModeDiv").style.visibility = "hidden";
          } else {
              document.querySelector("#loader").style.display = "none";
              document.querySelector(".navbar").style.display = "flex";
              document.querySelector("#main").style.display = "block";
              if (getUrlParameter('classmode') !== 'false') {
                  document.querySelector("#classModeDiv").style.visibility = "visible";
              }
          }
      };
      window.onload = () => {
          appendixSecNo = renumberAppendix();
          addMathContainers();
          theoremHelpers();
          addRefsToToc();
          eqRefExpandLinksAndAddTooltips();
          citeRefExpandLinksAndAddTooltips();
          secRefExpandLinksAndAddBackArrow(appendixSecNo);
          addFootnoteTooltips();
          addCodeCopyButtons();
          tocHelpers();
          drawAllSvgPlots();
          classModeSetup();
          videoEmbeds();
          document.onclick = closeClassMode;
          document.getElementById('main').onclick = closeNavIfSmall;
      }
      videoEmbeds = () => {
          for (el of document.getElementsByClassName('lectureVideoEmbed')) {
              ((el) => {
                  const descHTML = el.innerHTML;
                  const dt = el.getAttribute('data-video-date');
                  const dtStr = `${parseInt(dt.slice(5, 7))}/${parseInt(dt.slice(8, 10))}`
                  el.innerHTML = `&#127909;<small class="tinyText">Lecture video ${dtStr}</small>`;
                  el.style.cursor = 'pointer';
                  const embedIndentDiv = document.createElement('div');
                  embedIndentDiv.classList = ['embedIndent'];
                  el.appendChild(embedIndentDiv);
                  el.onclick = () => {
                      embedIndentDiv.style.display = embedIndentDiv.style.display == 'block' ? 'none' : 'block';
                  }
                  const textDiv = document.createElement('div');
                  textDiv.innerHTML = `<b>Class lecture ${dtStr}: </b>` + descHTML;
                  embedIndentDiv.appendChild(textDiv);
                  const vidIframe = document.createElement('iframe');
                  vidIframe.classList = ['lectureEmbedIframe'];
                  vidIframe.setAttribute('src', `https://mediasite.k-state.edu/mediasite/Play/${el.getAttribute('data-video-id')}?player=NextGenSystemPlayer&amp;cover=true&amp;lockControls=false&amp;coverTitle=false&amp;autoStart=false&amp;useExtensions=false&amp;disableXR=false&amp;quizzes=false&amp;hotspots=false&amp;clickToPlay=true&amp;playfrom=0`);
                  embedIndentDiv.appendChild(vidIframe);
              })(el)
          }
      }
      getUrlParameter = (name) => {
          name = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
          var regex = new RegExp('[\\?&]' + name + '=([^&#]*)');
          var results = regex.exec(location.search);
          return results === null ? '' : decodeURIComponent(results[1].replace(/\+/g, ' '));
      };
      addMathContainers = () => {
          for (el of document.querySelectorAll('.math.display')){
              katexContainer = document.createElement('div');
              katexContainer.classList = ['katexContainer'];
              el.parentNode.insertBefore(katexContainer, el);
              katexContainer.appendChild(el);
          }
      }
      renumberAppendix = () => {
          const appendixEl = document.getElementById('appendix') || document.getElementById('sec:appendix');
          const appendixSecNo = appendixEl.getAttribute('data-number');
          appendixEl.setAttribute('data-number', 'A');
          appendixEl.firstChild.remove();
          const appendixSections = [...document.getElementsByTagName('*')].filter(el => {
              return (el.getAttribute('data-number') || 'a').split('.')[0] === appendixSecNo;
          })
          for (apSec of appendixSections){
              const numSplit = apSec.getAttribute('data-number').split('.');
              const secNo = 'A.' + numSplit.slice(1).join('.');
              apSec.setAttribute('data-number', secNo);
              apSec.firstChild.textContent = secNo;
          }
          const tocEls = [...document.getElementsByClassName('toc-section-number')].filter(el => {
              return (el.textContent).split('.')[0] === appendixSecNo;
          })
          for (tocEl of tocEls) {
              if (tocEl.textContent == appendixSecNo){
                  tocEl.remove();
              } else {
                  const numSplit = tocEl.textContent.split('.');
                  const secNo = 'A.' + numSplit.slice(1).join('.');
                  tocEl.textContent = secNo;
              }
          }
          return appendixSecNo
      }
      tocHelpers = () => {
          for (el of document.querySelectorAll('#TOC a')){
              const hrefId = el.getAttribute('href').slice(1);
              let parentEl = el.parentNode;
              let numUlsNested = 0;
              while (!!parentEl){
                  numUlsNested += (parentEl.tagName == 'UL') ? 1 : 0
                  parentEl = parentEl.parentNode
              }
              innerHTML = el.innerHTML;
              el.innerHTML = '';
              newEl = document.createElement('div');
              newEl.innerHTML = innerHTML;
              newEl.style.marginLeft = numUlsNested * 0.4 + 'rem';
              newEl.style.display = 'flex';
              newEl.innerHTML = innerHTML;
              if (numUlsNested > 1) {
                  el.parentNode.classList.add('tocHideable');
                  el.parentNode.classList.add('tocHidden');
              } 
              liParent = el.parentNode;
              if (liParent.getElementsByTagName('UL').length > 0) {
                  expandEl = document.createElement('span');
                  expandEl.innerHTML = '&nbsp;+&nbsp;';
                  expandEl.classList = ['tocExpand'];
                  newEl.appendChild(expandEl);
                  ((expandEl, liParent) => {
                      expandEl.onclick = (e) => {
                          for (hideable of [...liParent.getElementsByClassName('tocHideable')]){
                              let hideableParent = hideable.parentNode;
                              while (hideableParent.tagName !== 'LI'){
                                  hideableParent = hideableParent.parentNode
                              }
                              if (hideableParent !== liParent) {
                                  continue
                              }
                              if ([...hideable.classList].includes('tocHidden')) {
                                  hideable.classList.remove('tocHidden');
                                  expandEl.innerHTML = '&nbsp;-&nbsp;';
                              } else {
                                  hideable.classList.add('tocHidden');
                                  expandEl.innerHTML = '&nbsp;+&nbsp;';
                              }
                          };
                          e.preventDefault();
                      }
                  })(expandEl, liParent)
              }
              el.appendChild(newEl);
          }
      }
      addCodeCopyButtons = () => {
          buttonAddFunc = () => {
              copyButtons = document.querySelectorAll('.copyButton');
              wide = 700;
              if (copyButtons.length > 0) {
                  if (window.innerWidth < wide) {
                      for (cb of copyButtons){
                          cb.remove();
                      }
                  }
              } else {
                  if (window.innerWidth >= wide) {
                      for (el of document.querySelectorAll('div.sourceCode')){
                          copyEl = document.createElement('span');
                          el.insertBefore(copyEl, el.firstChild);
                          copyEl.innerHTML = '📋';
                          copyEl.classList = ['copyButton'];
                          ((el, copyEl) => {
                              copyEl.onclick = () => {
                                  text = el.getElementsByTagName('pre')[0].textContent;
                                  navigator.clipboard.writeText(text);
                                  infoEl = document.createElement('div');
                                  infoEl.textContent = 'Copied!';
                                  infoEl.classList = ['copyMessage']
                                  copyEl.appendChild(infoEl);
                                  setTimeout(() => infoEl.remove(), 2000);
                              };
                          })(el, copyEl)
                      }
                  }
              }
          }
          buttonAddFunc();
          window.addEventListener("resize", buttonAddFunc);
      }
      addRefsToToc = () => {
          liEl = document.createElement('li');
          aEl = document.createElement('a');
          aEl.href = '#References';
          aEl.innerHTML = 'References';
          ulEl = document.getElementById('TOC').getElementsByTagName('ul')[0];
          liEl.appendChild(aEl);
          ulEl.appendChild(liEl);
      }
      addTooltips = (els, includeLinkBacks, arrowFloat=false) => {
          for ([i, el] of els.entries()) {
              ((el, i) => {
                  refId = el.getAttribute('href');
                  refEl = document.getElementById(refId.slice(1));
                  el.setAttribute('href', '#');
                  el.classList = ['eqnRef'];
                  nextEl = document.createElement('span');
                  el.parentNode.insertBefore(nextEl, el.nextSibling);
                  popupId = refId + 'popup' + i;
                  elId = popupId + 'Ref';
                  nextEl.id = elId;
                  ((a, b, c, d, e) => {
                      a.onclick = () => {
                          footnoteOnTooltipClick(b, c, d, e);
                          return false
                      };                
                  })(el, popupId, refEl.innerHTML, elId, includeLinkBacks ? refId.slice(1) : null)
                  if (includeLinkBacks) {
                      backId = 'back' + refId;
                      backEl = document.getElementById(backId);
                      if (!!!backEl) {
                          backEl = document.createElement('div');
                          backEl.id = backId;
                          backEl.classList = ['backRefElement'];
                          backArrowEl = document.createElement('a');
                          backArrowEl.id = backId + 'Arrow';
                          backArrowEl.innerHTML = "↩︎";
                          backArrowEl.style.display = 'none';
                          backEl.onclick = () => backEl.style.display = 'none';
                          backEl.appendChild(backArrowEl);
                          refEl.appendChild(backEl);
                      }
                  }
              })(el, i)
          }
      }
      expandLinks = (els, prevWordInclude) => {
          for (const el of els) {
              sib = el.previousSibling;
              sibTextSplit = sib.textContent.split(/\s+/).filter(s => s !== '');
              prevWord = sibTextSplit[sibTextSplit.length - 1].replace('(', '');
              if (prevWordInclude.includes(prevWord)){
                  repS = RegExp(`${prevWord}[^a-zA-Z]$`);
                  el.innerHTML = prevWord + ' ' + el.innerHTML;
                  sib.textContent = sib.textContent.replace(repS, '');
              }
          }
      }
      eqRefExpandLinksAndAddTooltips = () => {
          els = document.querySelectorAll('[href^="\#eq:"]');
          expandLinks(els, ['eq.', 'Equation']);
          addTooltips(els, true);
      }
      secRefExpandLinksAndAddBackArrow = (appendixSecNo) => {
          els = [...document.querySelectorAll('[href^="\#sec:"]')].filter(el => {
              return el.parentNode.tagName !== 'LI'
          });
          const appendixStr = 'the appendix';
          for (el of els) {
              if (el.textContent == appendixSecNo) {                
                  sib = el.previousSibling;
                  sib.remove();
                  el.textContent = appendixStr;
              } else {
                  el.textContent = document.getElementById(el.getAttribute('href').slice(1)).getAttribute('data-number');
              }
          }
          expandLinks(els.filter(el => el.textContent !== appendixStr), ['section']);
          for ([i, el] of els.entries()) {
              const secId = el.getAttribute('href').slice(1);
              const elId = 'linkToSec' + secId + i;
              el.id = elId;
              const toSec = document.getElementById(secId);
              el.onclick = () => {
                  backArrowId = secId + 'ReturnLink';
                  let backArrowEl = document.getElementById(backArrowId);
                  if (!!backArrowEl) {
                      backArrowEl.remove();
                  }
                  backArrowEl = document.createElement('a');
                  backArrowEl.id = backArrowId
                  backArrowEl.setAttribute('href', '#' + elId);
                  backArrowEl.style.float = 'right';
                  backArrowEl.innerHTML = "↩︎";
                  backArrowEl.onclick = () => backArrowEl.remove();
                  toSec.appendChild(backArrowEl);
              }
          }
      }
      citeRefExpandLinksAndAddTooltips = () => {
          els = document.getElementById('main').getElementsByClassName('citation');
          addTooltips([...els].map(el => el.getElementsByTagName('a')[0]), false);
          for (el of els) {
              textContent = el.textContent;
              el.getElementsByTagName('a')[0].textContent = textContent;
              for (childEl of el.childNodes) {
                  if (!!!childEl.tagName) {
                      childEl.textContent = '';
                  }
              }
          }
      }
      addFootnoteTooltips = () => {
          for (fnBack of [...document.getElementById('main').getElementsByClassName('footnote-back')]) {
              fnBack.remove();
          }
          els = document.getElementById('main').getElementsByClassName('footnote-ref');
          addTooltips([...els], false);
          document.getElementById('footnotes').remove();
          for (el of document.getElementsByClassName('eqnRef')) {
              const childEl = el.firstChild;
              if (childEl.tagName === 'SUP') {
                  childEl.textContent = 'note';
                  childEl.style.fontSize = '0.5rem';
              }
          }
      }
  </script>
  <!-- TOC styling adapted from https://www.w3schools.com/howto/howto_js_sidenav.asp -->
  <style>
      nav#TOC:nth-child(2) {
          margin-top: 0.6rem;
          box-shadow: rgba(0, 0, 0, 0.2) 2px 0px 10px 1px;
      }
      nav#TOC li {
          list-style-type: none;
      }
      nav#TOC > ul {
          margin-bottom: 1.5rem;
          margin-top: 2rem;
          line-height: 1.9rem;
      }
      #TOC ul {
          padding-left: 0;
      }
      nav#TOC {
          height: 100%;
          width: 0;
          position: fixed;
          z-index: 1;
          top: 0;
          left: 0;
          background-color: #ebebeb;
          overflow-x: hidden;
          padding-top: 1rem;
          transition: 0.5s;
          overflow-y: scroll;
      }
      nav#TOC a {
          text-decoration: none;
          font-size: max(1rem, min(calc(0.9rem + 0.4vw), 22pt));;
          color: #000;
          display: block;
          transition: 0.3s;
          padding-top: 0.2rem;
          padding-bottom: 0.3rem;
          border-bottom: 1pt solid lightgray;
      }
      nav#TOC a:hover {
          color: #888;
      }
      #TOC .toc-section-number::after {
          content: ':\00a0'
      }
      #tocTop {
          height: 1.5em;
          display: flex;
          justify-content: space-between;
          padding-top: 0.5rem;
          padding-bottom: 0.65rem;
          position: fixed;
          top: 0;
          visibility: hidden;
          background-color: #ebebeb;
          z-index: 1;
          border-bottom: 1pt solid gray;
      }
      .tocHidden {
          display: none     
      }
      .tocExpand {
          margin-left: auto;
          font-size: 30pt !important;
          font-family: 'Courier New', Courier, monospace;
      }
      .navbar {
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          font-size: 1.1rem;
          background-color: #ebebeb;
          width: 100%;
          border-bottom: 1pt solid gray;
          padding-top: 0.5rem;
          padding-bottom: 0.5rem;
          display: flex;
          justify-content: space-between;
          z-index: 2;
      }
      @media screen and (max-height: 450px) {
          .sidenav {
              padding-top: 15px;
          }

          .sidenav a {
              font-size: 18px;
          }
      }
  </style>
  <script>
      function openCloseNav() {
          const tocTop = document.getElementById("tocTop")
          if (tocTop.style.visibility == "visible") {
              closeNav();
              return
          }
          const screenWidth = window.innerWidth;
          const tocWidth = Math.min(0.75 * screenWidth, 350);
          const leftoverWidth = screenWidth - tocWidth;
          const main = document.getElementById("main");
          const mainWidth = main.offsetWidth;
          document.getElementById("TOC").style.width = tocWidth + 'px';
          tocTop.style.width = tocWidth + 'px';
          tocTop.style.visibility = "visible";
          if (leftoverWidth >= mainWidth) {
              main.style.marginLeft = tocWidth / 2 + 'px';
          }
      }
      function closeNav() {
          document.getElementById("TOC").style.width = "0";
          document.getElementById("main").style.marginLeft = null;
          document.getElementById("tocTop").style.visibility = "hidden";
      }
      function closeNavIfSmall() {
          if (document.getElementById("tocTop").style.visibility == "visible" && document.getElementById("main").style.marginLeft == 0){
              closeNav()
          }
      }
  </script>
  <style>
      .footnoteTooltipClose {
          color: #222;
          font-size: 30pt;
          font-weight: bold;
          margin-left: auto;
          margin-top: -1rem;
          margin-bottom: -1rem;
      }
      .footnoteTooltipClose:hover, .footnoteTooltipClose:focus {
          color: black;
          text-decoration: none;
          cursor: pointer;
      }
      .footnote-ref sup, .eqnRef {
          cursor: pointer;
          color: green !important;
      }
      .footnoteTooltip {
          background-color: #ebebeb;
          padding: 1rem;
          border: 1px solid #888;
          position: absolute;
          z-index: 1;
          width: 75%;
          left: 50%;
          transform: translateX(-50%);
          margin-top: 2rem;
          font-size: max(1rem, min(calc(0.9rem + 0.4vw), 22pt));
          overflow-x: auto;
          display: flex;
          flex-direction: column;
      }
      .eqnRef .footnoteTooltip {
          color: black;
      }
      .seeOriginalEq {
          font-size: 1rem;
          margin-left: auto;
      }
  </style>
  <script>
      function footnoteOnTooltipClick(id, innerHTML, refElOrId, origId) {
          innerHTML = innerHTML.replaceAll('@@@', '"');
          const tooltipEl = document.getElementById(id);
          if (tooltipEl == null) {
              const newEl = document.createElement("span");
              closeEl = document.createElement("div");
              closeEl.classList = ['footnoteTooltipClose'];
              closeEl.innerHTML = '&times;';
              newEl.appendChild(closeEl);
              if (typeof(refElOrId) === 'string'){
                  closeEl.setAttribute("onclick", "removeElById('" + id + "')");
                  document.getElementById(refElOrId).appendChild(newEl);
              } else {
                  closeEl.onclick = () => removeElById(id);
                  refElOrId.append(newEl);
              }
              newEl.id = id;
              newEl.innerHTML += innerHTML;
              newEl.classList = ['footnoteTooltip'];
              for (numEl of newEl.getElementsByClassName('eqnos-number')){
                  numEl.remove();
              }
              if (!!origId) {
                  seeOrigEl = document.createElement('a');
                  seeOrigEl.setAttribute('href', '#' + origId);
                  seeOrigEl.innerHTML = 'jump to';
                  seeOrigEl.classList = ['seeOriginalEq']
                  seeOrigEl.onclick = () => {
                      backEl = document.getElementById('back#' + origId + 'Arrow');
                      backEl.style.display = 'inline';
                      backEl.setAttribute('href', '#' + id)
                  }
                  newEl.appendChild(seeOrigEl);
              }
          } else {
              tooltipEl.remove();
          }
          
      }
      function removeElById(id) {
          document.getElementById(id).remove();
      }
  </script>
  <style>
      .eqnos {
          display: flex;
          align-items: center;
          width: 100%;
          overflow-x: auto;
      }
      .eqnos br {
          display: none;
      }
      .eqnos-number {
          margin-left: auto;
          padding-left: 1rem;
      }
      .katexContainer {
          flex-grow: 1;
          overflow-x: auto;
      }
  </style>
  <style>
      .lpDraw {
          position: relative;
          left: 50%;
          transform: translateX(-50%);
      }
      .pointChooseDiv {
          text-align: center;
      }
      .pointChooseInput {
          border: solid 1pt black;
          border-radius: 2pt;
          width: 2rem;
          height: 1.1rem;
      }
      .pointChooseLabel {
          font-size: 14pt;
          padding-left: 5pt;
          padding-right: 5pt;
      }
      .pointChooseText {
          text-align: center;
          font-size: max(12pt, 1rem);
      }
      .underPlot {
          margin-top: -10pt;
      }
      @keyframes append-animate {
          0% {
              stroke-width: 0;
          }
          25% {
              stroke-width: 4;
          }
          50% {
              stroke-width: 0;
          }
      }
      .violatedIneq {
          animation: append-animate 4s infinite;
      }
      @keyframes simplex-arrow-flash {
          0% {
              stroke-width: 3;
          }
          5% {
              stroke-width: 4;
          }
          10% {
              stroke-width: 3;
          }
          100% {
              stroke-width: 3;
          }
      }
      .simplexArrowChosen {
          animation: simplex-arrow-flash 12s infinite;
      }
      .simplexDirectionTable {
          margin: 0;
          margin-left: auto;
          margin-right: auto;
          width: 350px;
      }
      .pointChooseText button {
          font-size: 0.8rem;
          padding: 0.5rem;
          margin: 0 0.1rem;
      }
  </style>
  <style>
      .ytEmbedContainer {
          position: relative;
          padding-bottom: 56.25%;
          height: 0;
          overflow: hidden;
          max-width: 100%;
      } .ytEmbedContainer iframe, .ytEmbedContainer object, .ytEmbedContainer embed {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
      }
      .ytEmbedContainerContainer {
          max-width: 640px;
      }
  </style>
  <style>
      #main {
          font-size: max(1rem, min(calc(0.9rem + 0.4vw), 22pt));
          width: min(max(90%, calc(100% - min(60%, 350px) - 1rem)), 800px);
          position: absolute;
          left: 50%;
          transform: translateX(-50%);
          transition: margin-left .5s;
          padding: 20px;
          padding-bottom: 30px;
      }
      html {
          scroll-padding-top: 2.5rem;
          overflow-y: auto;
      }
      body {
          scroll-padding-top: 2.5rem;
          overflow-y: hidden;
          max-width: none !important;
      }
      .loadingMessage {
          text-align: center;
          margin-top: 40vh;
          font-size: 1.2rem;
      }
      blockquote {
          margin: 1rem 0.5rem;
          padding-left: 0.5em;
          padding-right: 0.5em;
          border-left: 2px solid #e6e6e6;
          border-right: 2px solid #e6e6e6;
          color: #444;
          background-color: #ebebeb;
      }
      blockquote p {
          padding-top: 0.5rem;
          padding-bottom: 0.5rem;
      }
      details {
          cursor: pointer;
      }
      figure {
          margin-inline: 0.5rem;
      }
      figure img {
          display: block;
          margin-left: auto;
          margin-right: auto;
          max-width: 100%;
      }
      figure figcaption {
          font-size: max(0.9rem, min(calc(0.8rem + 0.4vw), 20pt));;
          text-align: center;
      }
      a {
          color: blue;
      }
      a:visited {
          color: purple;
      }
      h1 {
          position: relative;
          margin-top: 5rem;
      }
      h1:before {
          content: '';
          position: absolute;
          width: 100%;
          height: 1px;
          background: black;
          bottom: 150%;
          left: 0;
      }
      *[role="doc-biblioref"] {
          color: green !important;
      }
      div.sourceCode {
          background-color: #dfdfdf;
          padding: 0.5rem;
          border: 1pt solid black;
          font-size: max(12pt, 1.1rem);
      }
      .copyButton {
          float: right;
          cursor: pointer;
      }
      .header-section-number::after {
          content: ':'
      }
      @keyframes fade {
          0%,100% { opacity: 0 }
          15% { opacity: 1 }
          85% { opacity: 1 }
      }
      .copyMessage {
          position: absolute;
          transform: translate(-2rem, -2.8rem);
          width: 4rem;
          font-size: max(10pt, 0.7rem);
          text-align: center;
          background-color: #eee;
          border: 1pt solid black;
          border-radius: 0.25rem;
          animation: fade 2s linear;
      }
      .backRefElement {
          margin-top: auto;
      }
      footer {
          position: fixed;
          bottom: 0;
          text-align: center;
          width: 100%;
          background: white;
          left: 50%;
          transform: translateX(-50%);
          border-top: 1pt solid lightgray;
          font-size: 0.7rem;
          display: flex;
          justify-content: space-between;
      }
      .embedIndent {
          margin: 0 1rem;
          display: none;
      }
      .lectureEmbedIframe {
          width: min(600px, 80vw);
          height: calc(9 * min(600px, 80vw) / 16);
      }
      .tinyText {
          font-size: 0.5rem;
      }
      .mathSmall {
          font-size: 1rem;
      }
  </style>
  <style>   
      #classModeDiv {
          position: fixed;
          width: min(max(80%, calc(100% - min(50%, 300px) - 1rem)), 700px);
          padding: 30pt;
          top: 200px;
          left: 50%;
          transform: translateX(-50%);
          background-color: white;
          border: 2pt solid;
          border-radius: 10pt;
          padding: 10px;
          box-shadow: 5px 5px rgb(200, 200, 200);
          visibility: hidden;
      }
  </style>
  <script>
      const classModeSetup = () => {
          const classMode = document.getElementById('classModeDiv');
          let noClassModeHref = window.location.href.split('#')[0];
          if (noClassModeHref[noClassModeHref.length - 1] !== '/') {
              noClassModeHref += '/';
          }
          noClassModeHref += '?classmode=false';
          classMode.onclick = closeClassMode;
          classMode.innerHTML = `
              <div>
                  Welcome to class mode! This is your friendly reminder to check that:
                  <ul>
                      <li>The mics are on.</li>
                      <li>The camera is pointed at the whiteboard.</li>
                      <li>PIP is off.</li>
                  </ul>
                  Click anywhere to close this window.
                  <div>To turn off class mode, click <a href=${noClassModeHref}>here</a>.</div>
              </div>
          `
      }
      const closeClassMode = () => {
          const classMode = document.getElementById('classModeDiv');
          const noClassModeHref = window.location.href.split('?')[0] + '/?classmode=false';
          const minutesBetweenReminders = 30;
          if (classMode.style.visibility === "visible") {
              classMode.style.visibility = "hidden";
              classMode.innerHTML = `
                  <div>
                      <div style='padding: 0.5rem;'>Hi! This is your periodic class mode reminder to:</div>
                      <div style='text-align:center;font-size:1.2rem;'><b>Check the microphone!</b></div>
                      <div style='padding: 0.5rem;'>Click anywhere to close this window.</div>
                      <div style='padding: 0.5rem;'>To turn off class mode, click <a href=${noClassModeHref}>here</a>.</div>
                  </div>
              `
              setTimeout(() => classMode.style.visibility = "visible", 1000 * 60 * minutesBetweenReminders);
          }
      }
  </script>
  <script>
      const theoremHelpers = () => {
          let theoremObj = {};
          for (thm of document.getElementsByClassName('theorem')) {
              ((thm) => {
                  let headerEl = thm.previousSibling;
                  while ( !['H1', 'H2', 'H3'].includes(headerEl.tagName)) {
                      headerEl = headerEl.previousSibling;
                  }
                  section = headerEl.getAttribute('data-number').split('.')[0];
                  theoremObj[thm.id] = {
                      'theorem': thm,
                      'proof': undefined,
                      'section': section
                  };
              })(thm)
          }
          for (prf of document.getElementsByClassName('proof')) {
              ((prf) => {
                  theoremObj[prf.getAttribute('for')].proof = prf;
                  firstP = prf.getElementsByTagName('p')[0];
                  firstP.innerHTML = '<b>Proof: </b>' + firstP.innerHTML;
              })(prf)
          }
          secNumThms = {};
          for ([thmId, thmObj] of Object.entries(theoremObj)) {
              ((thmId, thmObj) => {
                  thm = document.getElementById(thmId);
                  sec = thmObj.section;
                  el = thmObj.theorem;
                  proof = thmObj.proof;
                  if (!Object.keys(secNumThms).includes(sec)) {
                      secNumThms[sec] = 0;
                  }
                  secNumThms[sec] += 1;
                  thmTypeStr = thm.getAttribute('data-thm-type') || 'theorem';
                  thmTypeStr = thmTypeStr[0].toUpperCase() + thmTypeStr.slice(1);
                  el.setAttribute('refStr', `${thmTypeStr} ${sec}.${secNumThms[sec]}`)
                  labelSpan = document.createElement('span');
                  labelSpan.classList = ['theoremLabel'];
                  let preTheoremStr = `${thmTypeStr} ${sec}.${secNumThms[sec]}`
                  if (!!thm.getAttribute('data-display-name')) {
                      preTheoremStr += ` (${thm.getAttribute('data-display-name')})`
                  }
                  labelSpan.textContent = preTheoremStr + ': ';
                  el.insertBefore(labelSpan, el.firstChild);
                  const main = document.getElementById('main');
                  if (!!proof) {
                      if (proof.getAttribute('data-placement') === 'appendix') {
                          const appLink = document.createElement('p');
                          const thmClone = thm.cloneNode(true);
                          thmClone.id = thm.id + 'AppendixVersionWithProof';
                          thmCloneLabel = thmClone.firstChild;
                          thmCloneLabel.innerHTML = `<a href="#${thm.id}">${thmCloneLabel.textContent.trim()}</a>&nbsp;`
                          appLink.innerHTML = `(<a href="#${thmClone.id}">Proof</a> in the appendix.)`;
                          main.insertBefore(appLink, thm.nextSibling);
                          const refs = document.getElementById('References');
                          main.insertBefore(thmClone, refs);
                          main.insertBefore(proof, refs);
                      }
                  }
              })(thmId, thmObj)
          }
          const refEls = document.getElementsByClassName('thmRef');
          for (ref of refEls) {
              ((ref) => {
                  thm = document.getElementById(ref.getAttribute('for'));
                  ref.innerHTML = `<a href="#${thm.id}">${thm.getAttribute('refStr')}</a>`
              })(ref)
          }
          addTooltips([...refEls].map(el => el.firstChild), true);
      }
  </script>
  <style>
      .theorem p {
          font-style: italic;
          margin: 0;
          display: inline;
      }
      .theorem {
          border: 1pt solid gray;
          padding: 1rem;
          background-color: #eee;
      }
      .theoremLabel {
          font-weight: bold;
      }
      .proof::after {
          display: block;
          content: '\00220E';
          margin-top: -1.25rem;
          margin-bottom: 1rem;
      }
      .theorem .backRefElement {
          float: right;
      }
  </style>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<div class="navbar">
    <div onclick="openCloseNav()" style="padding-left: 1rem; cursor: pointer; color: blue">Contents</div>
    <div style="text-align: center">IMSE 780</div>
    <div style="text-align: right; padding-right: 1rem">Fall 2023</div>
</div>
<div id="loader" class="loadingMessage">Loading...</div>
<nav id="TOC" role="doc-toc">
<div id="tocTop"></div>
<ul>
<li><a href="#welcome" id="toc-welcome"><span
class="toc-section-number">1</span> Welcome!</a>
<ul>
<li><a href="#course-materials" id="toc-course-materials"><span
class="toc-section-number">1.1</span> Course materials</a></li>
<li><a href="#notes-on-these-notes" id="toc-notes-on-these-notes"><span
class="toc-section-number">1.2</span> Notes on these notes</a></li>
</ul></li>
<li><a href="#introduction-to-or" id="toc-introduction-to-or"><span
class="toc-section-number">2</span> Introduction to OR</a>
<ul>
<li><a href="#what-is-operations-research"
id="toc-what-is-operations-research"><span
class="toc-section-number">2.1</span> What is Operations
Research?</a></li>
<li><a href="#example-or-problems" id="toc-example-or-problems"><span
class="toc-section-number">2.2</span> Example OR problems</a>
<ul>
<li><a href="#traveling-salesman-problem"
id="toc-traveling-salesman-problem"><span
class="toc-section-number">2.2.1</span> Traveling Salesman
Problem</a></li>
<li><a href="#job-shop-scheduling" id="toc-job-shop-scheduling"><span
class="toc-section-number">2.2.2</span> Job-shop scheduling</a></li>
<li><a href="#portfolio-optimization"
id="toc-portfolio-optimization"><span
class="toc-section-number">2.2.3</span> Portfolio optimization</a></li>
</ul></li>
<li><a href="#or-in-practice" id="toc-or-in-practice"><span
class="toc-section-number">2.3</span> OR in practice</a>
<ul>
<li><a href="#origins-of-or" id="toc-origins-of-or"><span
class="toc-section-number">2.3.1</span> Origins of OR</a></li>
<li><a href="#case-studies" id="toc-case-studies"><span
class="toc-section-number">2.3.2</span> Case studies</a></li>
<li><a href="#edelman-prize" id="toc-edelman-prize"><span
class="toc-section-number">2.3.3</span> Edelman Prize</a></li>
</ul></li>
<li><a href="#topics-well-cover" id="toc-topics-well-cover"><span
class="toc-section-number">2.4</span> Topics we’ll cover</a></li>
</ul></li>
<li><a href="#python-crash-course" id="toc-python-crash-course"><span
class="toc-section-number">3</span> Python crash course</a>
<ul>
<li><a href="#google-colab-notebooks"
id="toc-google-colab-notebooks"><span
class="toc-section-number">3.1</span> Google Colab notebooks</a></li>
<li><a href="#some-python-basics" id="toc-some-python-basics"><span
class="toc-section-number">3.2</span> Some Python basics</a></li>
<li><a href="#other-coding-environments"
id="toc-other-coding-environments"><span
class="toc-section-number">3.3</span> Other coding environments</a>
<ul>
<li><a href="#local-development" id="toc-local-development"><span
class="toc-section-number">3.3.1</span> Local development</a></li>
<li><a href="#cloud-hosted" id="toc-cloud-hosted"><span
class="toc-section-number">3.3.2</span> Cloud hosted</a></li>
</ul></li>
</ul></li>
<li><a href="#linear-programming" id="toc-linear-programming"><span
class="toc-section-number">4</span> Linear programming</a>
<ul>
<li><a href="#sec:exampleLp" id="toc-sec:exampleLp"><span
class="toc-section-number">4.1</span> An example LP</a>
<ul>
<li><a href="#formulating-our-first-lp"
id="toc-formulating-our-first-lp"><span
class="toc-section-number">4.1.1</span> Formulating our first
LP</a></li>
</ul></li>
<li><a href="#lp-terminology" id="toc-lp-terminology"><span
class="toc-section-number">4.2</span> LP terminology</a></li>
<li><a href="#lp-visualized" id="toc-lp-visualized"><span
class="toc-section-number">4.3</span> LP visualized</a>
<ul>
<li><a href="#solving-an-lp-visually"
id="toc-solving-an-lp-visually"><span
class="toc-section-number">4.3.1</span> Solving an LP visually</a></li>
<li><a href="#visualizing-other-scenarios"
id="toc-visualizing-other-scenarios"><span
class="toc-section-number">4.3.2</span> Visualizing other
scenarios</a></li>
</ul></li>
<li><a href="#solving-lps-with-software"
id="toc-solving-lps-with-software"><span
class="toc-section-number">4.4</span> Solving LPs with software</a>
<ul>
<li><a href="#modeling-languages" id="toc-modeling-languages"><span
class="toc-section-number">4.4.1</span> Modeling languages</a></li>
<li><a href="#solvers" id="toc-solvers"><span
class="toc-section-number">4.4.2</span> Solvers</a></li>
<li><a href="#solving-our-lp-with-python"
id="toc-solving-our-lp-with-python"><span
class="toc-section-number">4.4.3</span> Solving our LP with
Python</a></li>
<li><a href="#modeldata-separation" id="toc-modeldata-separation"><span
class="toc-section-number">4.4.4</span> Model/data separation</a></li>
</ul></li>
<li><a href="#sec:lpForms" id="toc-sec:lpForms"><span
class="toc-section-number">4.5</span> LP forms</a>
<ul>
<li><a href="#standard-form" id="toc-standard-form"><span
class="toc-section-number">4.5.1</span> Standard form</a></li>
<li><a href="#minimization-problems"
id="toc-minimization-problems"><span
class="toc-section-number">4.5.2</span> Minimization problems</a></li>
<li><a href="#sec:lpConstraintTransform"
id="toc-sec:lpConstraintTransform"><span
class="toc-section-number">4.5.3</span> Different constraint
forms</a></li>
<li><a href="#sec:lpVariableBoundTransform"
id="toc-sec:lpVariableBoundTransform"><span
class="toc-section-number">4.5.4</span> Variable bounds</a></li>
<li><a href="#recap-of-allowed-forms"
id="toc-recap-of-allowed-forms"><span
class="toc-section-number">4.5.5</span> Recap of allowed forms</a></li>
<li><a href="#different-notation" id="toc-different-notation"><span
class="toc-section-number">4.5.6</span> Different notation</a></li>
</ul></li>
<li><a href="#the-simplex-method" id="toc-the-simplex-method"><span
class="toc-section-number">4.6</span> The simplex method</a>
<ul>
<li><a href="#corner-point-solutions"
id="toc-corner-point-solutions"><span
class="toc-section-number">4.6.1</span> Corner-point solutions</a></li>
<li><a href="#sec:simplexVisualized"
id="toc-sec:simplexVisualized"><span
class="toc-section-number">4.6.2</span> Simplex visualized</a></li>
<li><a href="#augmented-form-and-basic-solutions"
id="toc-augmented-form-and-basic-solutions"><span
class="toc-section-number">4.6.3</span> Augmented form and basic
solutions</a></li>
<li><a href="#sec:simplexExample" id="toc-sec:simplexExample"><span
class="toc-section-number">4.6.4</span> Solving the sample LP with
simplex</a></li>
<li><a href="#simplex-in-matrix-notation"
id="toc-simplex-in-matrix-notation"><span
class="toc-section-number">4.6.5</span> Simplex in matrix
notation</a></li>
<li><a href="#presenting-finally-the-simplex-algorithm-mostly"
id="toc-presenting-finally-the-simplex-algorithm-mostly"><span
class="toc-section-number">4.6.6</span> Presenting (finally) the simplex
algorithm (mostly)</a></li>
<li><a href="#sec:lpOtherConsiderations"
id="toc-sec:lpOtherConsiderations"><span
class="toc-section-number">4.6.7</span> Other considerations</a></li>
<li><a href="#the-revised-simplex-method"
id="toc-the-revised-simplex-method"><span
class="toc-section-number">4.6.8</span> The revised simplex
method</a></li>
</ul></li>
</ul></li>
<li><a href="#appendix" id="toc-appendix"><span
class="toc-section-number">5</span> Appendix</a>
<ul>
<li><a href="#sec:symbols" id="toc-sec:symbols"><span
class="toc-section-number">5.1</span> Special symbols</a></li>
<li><a href="#sec:linearAlgebra" id="toc-sec:linearAlgebra"><span
class="toc-section-number">5.2</span> Linear algebra review</a>
<ul>
<li><a href="#sec:matrixMath" id="toc-sec:matrixMath"><span
class="toc-section-number">5.2.1</span> Matrix math</a></li>
<li><a href="#properties-of-matrix-operations"
id="toc-properties-of-matrix-operations"><span
class="toc-section-number">5.2.2</span> Properties of matrix
operations</a></li>
<li><a href="#special-matrices" id="toc-special-matrices"><span
class="toc-section-number">5.2.3</span> Special matrices</a></li>
<li><a href="#rank-and-inverse" id="toc-rank-and-inverse"><span
class="toc-section-number">5.2.4</span> Rank and inverse</a></li>
<li><a href="#systems-of-equations" id="toc-systems-of-equations"><span
class="toc-section-number">5.2.5</span> Systems of equations</a></li>
<li><a href="#sec:elementaryRowOperations"
id="toc-sec:elementaryRowOperations"><span
class="toc-section-number">5.2.6</span> Elementary operations</a></li>
</ul></li>
<li><a href="#sec:appendixSelectedProofs"
id="toc-sec:appendixSelectedProofs"><span
class="toc-section-number">5.3</span> Selected proofs</a></li>
</ul></li>
</ul>
</nav>
<div id="main">
<h1 data-number="1" id="welcome"><span
class="header-section-number">1</span> Welcome!</h1>
<div class="lectureVideoEmbed"
data-video-id="97611387a9ca4d1bae07842bec132e081d"
data-video-date="2023-08-21">
Going over the syllabus, class/instructor introduction.
</div>
<p>You’re reading the class notes for <em>IMSE 780: Methods of
Operations Research</em> taught at Kansas State University during the
Fall 2023 semester. This course is intended to give an overview of
Operations Research (OR) at the graduate level. After this course,
students will have a basic familiarity with various OR methodologies and
be able to recognize when the methods can be applied in real-life
scenarios. Students should also be able to apply the chosen methodology
via Python code.</p>
<h2 data-number="1.1" id="course-materials"><span
class="header-section-number">1.1</span> Course materials</h2>
<p>The core of this course will be taught from these notes.
Additionally, I encourage students to use the textbook <em>Introduction
to Operations Research</em> <span class="citation"
data-cites="classText">(<a href="#ref-classText"
role="doc-biblioref">Hillier and Lieberman 2021</a>)</span> as a
reference<a href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a>. The syllabus, assignments, and
other course materials may be found via the <a
href="https://k-state.instructure.com/">class Canvas site</a>.</p>
<h2 data-number="1.2" id="notes-on-these-notes"><span
class="header-section-number">1.2</span> Notes on these notes</h2>
<p>I wrote the notes in this format in an attempt to alleviate all my
past frustrations from reading academic material in all formats. Things
like unlinked references, or links requiring context switches and
without back navigation. Or static elements that could be more effective
if animated or interactive. So I tried to fix some of those issues with
this format.</p>
<p>That means these notes were necessarily made with my desires in mind,
and not yours, the reader trying to learn from them. So I’d love any
feedback you have on how the notes are presented, or anything you think
I could add to help your learning. I can’t guarantee I’ll be able to
change much substantial at this point, but at the very least future
iterations of these notes could incorporate your changes and help future
learners.</p>
<p>Also, errors. I’m trying my best to keep these notes free of typos
and factual errors, but inevitably several will slip through. I’d be
grateful if you can point these out as you see them. I’ll even keep a
leaderboard of who has pointed out the most errors, and will have a
prize at the end of the semester for the largest contributors.</p>
<p>I made these notes mostly for consumption on your web browser on a
laptop/desktop computer, or a tablet in landscape orientation. You can
still access them on your phone, of course, and I’ve tried to style
things such that the content is as usable as possible on a narrow
screen, but your best experience will be on a larger screen. If you’d
like hard copies of these notes, your only option for now is to print
from your browser. With some extra work, I could make pdf versions
available as well, although you will necessarily lose some functionality
in that format. If this is something you’d be interested in, please let
me know.</p>
<p>These notes were created for educational use. With proper
attribution, readers may freely copy, distribute, or produce derivative
work from this content, in whole or in part, for any non-commercial
use.</p>
<h1 data-number="2" id="introduction-to-or"><span
class="header-section-number">2</span> Introduction to OR</h1>
<div class="lectureVideoEmbed"
data-video-id="36726575b4244fecb73986d444ffae771d"
data-video-date="2023-08-23">
Chapter 2, Edelman prize, a little about Python at the end.
</div>
<p>In this section we’ll cover the big picture questions: What is
Operations Research? Where did it come from? What can I do with it? I
hope to impress upon you that OR is a seriously set of tools, and that
it has a huge impact on the world today.</p>
<h2 data-number="2.1" id="what-is-operations-research"><span
class="header-section-number">2.1</span> What is Operations
Research?</h2>
<p>If you’re like me, one of the first things you’ll do when learning a
new subject is look it up on Wikipedia. As of this writing, <a
href="https://en.wikipedia.org/wiki/Operations_research">their page on
Operations Research</a> first defines OR as:</p>
<blockquote>
<p>The discipline that deals with the development and application of
analytical methods to improve decision-making.</p>
</blockquote>
<p>I think this is a good first definition! Continuing on a bit, the
article gets a little more specific:</p>
<blockquote>
<p>Employing techniques from other mathematical sciences, such as
modeling, statistics, and optimization, operations research arrives at
optimal or near-optimal solutions to decision-making problems.</p>
</blockquote>
<p>Right. So the practice of OR involves using mathematical techniques
to find the best decision possible in a given situation (“optimal” is
just fancy way of saying “best”<a href="#fn2" class="footnote-ref"
id="fnref2" role="doc-noteref"><sup>2</sup></a>).</p>
<h2 data-number="2.2" id="example-or-problems"><span
class="header-section-number">2.2</span> Example OR problems</h2>
<p>The above definitions were great, but maybe it’s feeling a little too
abstract at this point. Fair enough. Let’s outline a few common problems
in the OR space.</p>
<h3 data-number="2.2.1" id="traveling-salesman-problem"><span
class="header-section-number">2.2.1</span> Traveling Salesman
Problem</h3>
<p>There are many well-known problems in the world of OR, but I reckon
the <a
href="https://en.wikipedia.org/wiki/Travelling_salesman_problem">Traveling
Salesman Problem</a> (TSP) is the best-known and most-loved among them.
The setup is simple: Some old-timey door-to-door salesman is heading out
on the road to sell his product to the masses. He plans to visit a
certain group of cities, and thanks to his trusty atlas he knows the way
between any pair of cities. Less clear, however, is the shortest path
that will lead you through <em>all</em> of the cities, and this is the
aim of the TSP: In which order should you visit the cities such that
your total distance traveled is minimized?</p>
<p>As I said, this a famous problem in the OR space<a href="#fn3"
class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>. I
think it’s due to the simple, relatable exposition, paired with the fact
that it is actually quite computationally challenging. And yet despite
the challenges, modern methods are able to solve problem instances where
the number of cities is in the 10,000s! The image below shows the
optimal tour through selected cities in the continental US<a href="#fn4"
class="footnote-ref" id="fnref4"
role="doc-noteref"><sup>4</sup></a>.</p>
<figure>
<img
src="https://www.math.uwaterloo.ca/tsp/usa50/img/newsweek_medium.jpg"
alt="The shortest tour through 49 US cities (“Waterloo TSP,” n.d.)" />
<figcaption aria-hidden="true">The shortest tour through 49 US cities
<span class="citation" data-cites="tspPic">(<a href="#ref-tspPic"
role="doc-biblioref"><span>“Waterloo TSP,”</span>
n.d.</a>)</span></figcaption>
</figure>
<h3 data-number="2.2.2" id="job-shop-scheduling"><span
class="header-section-number">2.2.2</span> Job-shop scheduling</h3>
<p>You run a machine shop, and have a certain number of jobs to complete
in a day. Each job requires a certain number of tasks to be done by one
of your many machines, and the tasks are at least partially ordered,
such that you must complete some of the tasks in a certain order. Each
machine can only work on one task at a time. You get to decide the work
schedule, assigning machines to tasks at certain times in the day. What
is the schedule that lets you complete all the jobs in the least amount
of time?</p>
<p>An example: You have a woodworking shop, and today you’re making 20
table, 30 chairs, 15 doors, and 20 bookcases. Each of these jobs
requires some time on your table saw, your mill, and your belt sander.
And the order of operations matters, e.g. you have to cut a piece of
wood before you sand the edges. When you begin the day, what job will
you have each of your machines work on? And as they complete those jobs,
which ones should they take up next? How much time can you save with the
right schedule of work?</p>
<h3 data-number="2.2.3" id="portfolio-optimization"><span
class="header-section-number">2.2.3</span> Portfolio optimization</h3>
<p>You have some money to invest, and a list of potential project/assets
to invest in. You’d like to invest in a way that gives you a high
expected return, but there is risk involved as well. Each project comes
with its own risks, and some projects may be highly correlated such that
failure in one would suggest a high chance of failure in another. How
can you deploy your capital in a way that minimizes downside risk while
still likely generating a good profit?</p>
<h2 data-number="2.3" id="or-in-practice"><span
class="header-section-number">2.3</span> OR in practice</h2>
<p>So we’ve given a few broad classes of OR problems, but these are
still just hypotheticals. You’d probably like some concrete examples,
instances where OR has been used in the real world, and what the results
were.</p>
<h3 data-number="2.3.1" id="origins-of-or"><span
class="header-section-number">2.3.1</span> Origins of OR</h3>
<p>We’ll come to the present day soon, but let’s start with a (brief)
history lesson. Most sources trace the beginning of OR back to early
1900s and the two World Wars. This <em>research</em> on military
<em>operations</em> is where the discipline’s name derives. Here’s how
<span class="citation" data-cites="classText">Hillier and Lieberman (<a
href="#ref-classText" role="doc-biblioref">2021</a>)</span> explains
it:</p>
<blockquote>
<p>The roots of OR can be traced back many decades, when early attempts
were made to use a scientific approach in the management of
organizations. However, the beginning of the activity called operations
research has generally been attributed to the military services early in
World War II. Because of the war effort, there was an urgent need to
allocate scarce resources to the various military operations and to the
activities within each operation in an effective manner. Therefore, the
British and then the U.S. military management called upon a large number
of scientists to apply a scientific approach to dealing with this and
other strategic and tactical problems. In effect, they were asked to do
<em>research</em> on (military) <em>operations</em>. These teams of
scientists were the first OR teams. By developing effective methods of
using the new tool of radar, these teams were instrumental in winning
the Air Battle of Britain. Through their research on how to better
manage convoy and antisubmarine operations, they also played a major
role in winning the Battle of the North Atlantic. Similar efforts
assisted the Island Campaign in the Pacific.</p>
</blockquote>
<p>After the war, these techniques were adopted by industry as well. As
the sheer scale of organizations began to grow, so did the potential
benefit of the optimized systems brought by OR methodologies. As
techniques and (especially) computing power improved, the types and
scale of problems that were tackled continued to grow. Today almost all
major corporations benefit from OR.</p>
<h3 data-number="2.3.2" id="case-studies"><span
class="header-section-number">2.3.2</span> Case studies</h3>
<p>Your textbook handily comes full of case studies explaining how
companies have used OR to inform their decision-making. Below I’ve
copied part of the summary table. Check out the book to get more
background on anything that piques your interest.</p>
<figure>
<img src="images/or-case-studies.png"
alt="Selected OR case studies (Hillier and Lieberman 2021)" />
<figcaption aria-hidden="true">Selected OR case studies <span
class="citation" data-cites="classText">(<a href="#ref-classText"
role="doc-biblioref">Hillier and Lieberman 2021</a>)</span></figcaption>
</figure>
<p>It’s pretty staggering to look at the figures in the “Annual Savings”
column, which taken together sum to the billions. OR is an enormously
valuable tool.</p>
<h3 data-number="2.3.3" id="edelman-prize"><span
class="header-section-number">2.3.3</span> Edelman Prize</h3>
<p>Now, admittedly, some of those case studies are a little stale. But
don’t fret, OR is still relevant in industry today. A great showcase for
the most recent impactful OR work is the annual Edelman Prize, awarded
by the <a href="https://www.informs.org/">Institute for Operations
Research and Management Science (INFORMS)</a>. The winners of this award
were judged to have demonstrated the best application of OR
methodologies in industry. You can take a look at the <a
href="https://3449182.fs1.hubspotusercontent-na1.net/hubfs/3449182/2023_Edelman_Gala_Book.pdf">program
for the 2023 edition of the award</a> and find cases submitted by names
like DHL, Huawei, Lyft, and the winner Walmart.</p>
<h2 data-number="2.4" id="topics-well-cover"><span
class="header-section-number">2.4</span> Topics we’ll cover</h2>
<p>OR is a wide-ranging topic, and as such we can’t cover everything.
Since the class is meant to be an overview, we won’t get overly deep
into any one topic either<a href="#fn5" class="footnote-ref" id="fnref5"
role="doc-noteref"><sup>5</sup></a>. But we should be able to cover the
basics in a handful of important topics, as well as getting you some
hand-on experience using these methods to solve problems. I’ve outlined
the planned programming below, but note that we are still early in the
semester, so some of this may be subject to change.</p>
<p>My main goal for this course is for you to be able to apply the
methods we learn. We will accomplish this using various packages written
for the Python programming language. While this is not a programming
course, I realize some of you may have limited (or no) knowledge of the
language, thus I’ve provided a small unit on the basics. But if you are
a true beginner this may not suffice, and you may need to spend time on
your own to get comfortable with it.</p>
<p>After that, we will jump into the first big success in Operations
Research history, linear programming. We’ll learn about the basics of
these models, a little history, and a few ways to solve them (with
special emphasis on the simplex method). We’ll also touch on the theory
of duality and sensitivity analysis.</p>
<p>After linear programming comes its cousin, integer programming. As
far as solving techniques, we’ll focus on branch-and-bound and
branch-and-cut. Since integer programming is so powerful, we will spend
significant time talking about how to model these problems, and how to
set them up and solve them with Python.</p>
<p>Next will be several topics in nonlinear programming where we will
talk about convexity, optimality conditions, and selected solution
procedures.</p>
<p>We will also include a section on Stochastic Processes, where we will
cover topics in Markov chains, queueing theory, and perhaps Markov
Decision Processes.</p>
<p>There are a few other topics on my mind (dynamic programming, network
models) that I may decide to cover depending on time and class
interest.</p>
<h1 data-number="3" id="python-crash-course"><span
class="header-section-number">3</span> Python crash course</h1>
<div class="lectureVideoEmbed"
data-video-id="ec3e6d7c7e5e4e63bc3541c58c8a54c91d"
data-video-date="2023-08-25">
Python basics. The video cut off a bit at the end, but you don’t miss
anything important.
</div>
<p>A main focus of the course is to show you how to model and solve
real-world problems. In order to do that, you’ll need some programming
abilities. <a href="https://www.python.org/">Python</a> is a great
choice for this since it is widely-used and relatively easy to learn.
You may have some experience with Python already, which is great! If
you’ve never used Python before, don’t worry. We’ll spend a little time
on the basics here, and we won’t require you to do much out of the
ordinary. Beginners will want to get some more practice outside of
class.</p>
<h2 data-number="3.1" id="google-colab-notebooks"><span
class="header-section-number">3.1</span> Google Colab notebooks</h2>
<p>You can code Python in many different environments, but I think the
easiest way to get started is with <a
href="https://colab.google/">Google Colab</a>. This is a <a
href="https://jupyter.org/">Jupyter</a>-like<a href="#fn6"
class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>
notebook environment that is free to use and requires only a web
browser. I’ll be using this in class to go through coding examples. Note
that you need a Google account in order to fully use Colab<a href="#fn7"
class="footnote-ref" id="fnref7"
role="doc-noteref"><sup>7</sup></a>.</p>
<p>In Colab (and other notebook environments) code is organized into
cells where related blocks of code are written. You can execute code one
cell at a time to work through the notebook and check outputs as you go.
I’ll use a Colab notebook in the next section to walk through some
basics of Python.</p>
<h2 data-number="3.2" id="some-python-basics"><span
class="header-section-number">3.2</span> Some Python basics</h2>
<p>Below, you should see a read-only image of a Colab notebook. The
notebook gives some exposition and samples of basic Python principles.
Click the “Open in Colab” button to open a copy in your browser.</p>
<script src="https://gist.github.com/dcd6305c13b79bbdba7c49dc5c76d3c7.js"></script>
<h2 data-number="3.3" id="other-coding-environments"><span
class="header-section-number">3.3</span> Other coding environments</h2>
<p>I suggest Colab because it is free and easy to set up, and it should
work well for what you’ll need during the course. But it is far from the
only option for Python, and often not the best option depending on your
needs. Here are a few other options to explore on your own:</p>
<h3 data-number="3.3.1" id="local-development"><span
class="header-section-number">3.3.1</span> Local development</h3>
<p>Unlike Colab, where the computing is done on a cloud-based virtual
machine accessed through your web browser, these next few options run
completely on your local machine. They’ll all require installing
Python<a href="#fn8" class="footnote-ref" id="fnref8"
role="doc-noteref"><sup>8</sup></a> along with other software, but you
won’t need an internet connection to use them. This is not an exhaustive
list, just tools that I’ve used and liked.</p>
<ul>
<li><a href="https://jupyter.org/">Jupyter</a>: The first popular
notebook environment for Python. It functions much like Colab does,
though there are minor differences. Several places offer web-hosted
versions of Jupyter too.</li>
<li><a href="https://www.jetbrains.com/pycharm/">Pycharm</a>: Pycharm is
an <a
href="https://en.wikipedia.org/wiki/Integrated_development_environment">IDE</a>
built for Python, and as such comes with support for debugging,
refactoring, run configurations, and more. There is a free version and a
pro version, but the free version has plenty of functionality and is
more than sufficient for the coding in this course.</li>
<li><a href="https://code.visualstudio.com/">Visual Studio Code</a>: VS
Code is a popular, free IDE that supports many different programming
languages. It is highly customizable and there is a broad ecosystem of
extensions that can enhance functionality.</li>
</ul>
<h3 data-number="3.3.2" id="cloud-hosted"><span
class="header-section-number">3.3.2</span> Cloud hosted</h3>
<p>There are several cloud-hosted options available for running Python.
We’ve already mentioned Colab, and there are myriad other places that
offer cloud-hosted notebooks at varying price points. Offerings that I’m
familiar with<a href="#fn9" class="footnote-ref" id="fnref9"
role="doc-noteref"><sup>9</sup></a>:</p>
<ul>
<li><a href="https://ide.cloud.google.com">Google Cloud Shell/IDE</a>:
If you have a Google Cloud Platform account, you have access to a
cloud-based virtual machine known as the Google Cloud Shell. The shell
comes with Python and other common developer tools pre-installed, and
you can interact with it using their Cloud IDE, a hosted VS Code-like
environment. The shell runs a pretty small machine, but it is free to
use and you can use the IDE for up to 50 hours per week.</li>
<li><a
href="https://cloud.google.com/vertex-ai/docs/workbench/introduction">Vertex
AI Notebooks</a>: Managed Jupyter notebooks on Google Cloud Platform.
You do have to pay for the service and the associated compute time and
storage. There are similar offerings from <a
href="https://aws.amazon.com/sagemaker/notebooks/">Amazon Web
Services</a> and <a
href="https://learn.microsoft.com/en-us/azure/machine-learning/how-to-run-jupyter-notebooks?view=azureml-api-2">Microsoft
Azure</a></li>
<li><a href="https://www.gitpod.io/">Gitpod</a>: Gitpod is a service
that offers on-demand cloud development environments that are highly
customizable. This one is a little more advanced, and all machine
instances need to be backed by some <a
href="https://git-scm.com/">git</a> repository (e.g. on <a
href="https://github.com/">GitHub</a>). So I wouldn’t start here, but
for the right use-case it is a nice service. Their free plan gets you up
to 50 hours per month.</li>
</ul>
<h1 data-number="4" id="linear-programming"><span
class="header-section-number">4</span> Linear programming</h1>
<div class="lectureVideoEmbed"
data-video-id="0b552ccb31c34eab8f6f6d658afd32c61d"
data-video-date="2023-08-28">
Intro to linear programming (sections 4.1-4.3)
</div>
<p>In the family of OR techniques, linear programming (LP) is certainly
the matriarch. It was among the first methods to be seriously studied
and find broad applications. To this day, LPs are relevant and used
across industry to inform decision-making and help best make use of
scarce resources.</p>
<p>So, what is an LP? Let’s step back a bit - linear programming is a
special type of mathematical programming problem. The word
<em>programming</em>, in the language of the pre-computer-revolution era
where these topics were first studied, was more or less a synonym for
<em>planning</em>. So mathematical programming just means using math to
make a plan.</p>
<p>And the linear part? This refers to the form of the mathematical
objects used. All mathematical programs have <em>variables</em>
(quantities you get to set in order to get a desirable result),
<em>constraints</em> (limitations on how you can set your variables),
and an <em>objective</em> (the quantity you want to maximize/minimize).
In linear programming, all constraints and objectives must be
<em>linear</em> functions of your variables. Meaning, you can multiply
the variables by constants and add them together. No higher order terms,
like squaring a variable or multiplying two variables together. We’ll
see an example in the next section.</p>
<h2 data-number="4.1" id="sec:exampleLp"><span
class="header-section-number">4.1</span> An example LP</h2>
<p>Before we pile up too many definitions, maybe we should see an
example problem where we can get more hands-on. The following comes from
<span class="citation" data-cites="classText">Hillier and Lieberman (<a
href="#ref-classText" role="doc-biblioref">2021</a>)</span>, section
3.1.</p>
<blockquote>
<p>The Wyndor Glass Co. produces high-quality glass products, including
windows and glass doors. It has three plants. Aluminum frames and
hardware are made in Plant 1, wood frames are made in Plant 2, and Plant
3 produces the glass and assembles the products. Because of declining
earnings, top management has decided to revamp the company’s product
line. Unprofitable products are being discontinued, releasing production
capacity to launch two new products having large sales potential:</p>
<ul>
<li>Product 1: An 8-foot glass door with aluminum framing</li>
<li>Product 2: A 4 x 6 foot double-hung wood-framed window</li>
</ul>
<p>Product 1 requires some of the production capacity in Plants 1 and 3,
but none in Plant 2. Product 2 needs only Plants 2 and 3. The marketing
division has concluded that the company could sell as much of either
product as could be produced by these plants. However, because both
products would be competing for the same production capacity in Plant 3,
it is not clear which mix of the two products would be most
profitable.</p>
</blockquote>
<p>Together with management, the company’s OR team defines the problem
as follows:</p>
<blockquote>
<p>Determine what the production rates should be for the two products in
order to maximize their total profit, subject to the restrictions
imposed by the limited production capacities available in the three
plants. (Each product will be produced in batches of 20, so the
production rate is defined as the number of batches produced per week.)
Any combination of production rates that satisfies these restrictions is
permitted, including producing none of one product and as much as
possible of the other.</p>
</blockquote>
<p>The team’s next task is to gather data on production runs and
potential profits. The findings are summarized in the table below:</p>
<figure>
<img src="images/lp-example-data.png"
alt="Data for the Wyndor Glass Co. problem (Hillier and Lieberman 2021)" />
<figcaption aria-hidden="true">Data for the Wyndor Glass Co. problem
<span class="citation" data-cites="classText">(<a href="#ref-classText"
role="doc-biblioref">Hillier and Lieberman 2021</a>)</span></figcaption>
</figure>
<h3 data-number="4.1.1" id="formulating-our-first-lp"><span
class="header-section-number">4.1.1</span> Formulating our first LP</h3>
<p>How do we go about formulating this problem mathematically? We must
first decide on the <em>decision variables</em>, the quantities we get
to choose in order to affect profit. In this case, the variables are the
quantities of Product 1 and Product 2 that we choose to produce. We will
denote these quantities by <span class="math inline">x_1</span> and
<span class="math inline">x_2</span> respectively. That is, <span
class="math inline">x_1</span> is the number of batches of Product 1 we
will produce in a week, and <span class="math inline">x_2</span> is the
number of batches of Product 2 we produce in a week.</p>
<p>Next let’s talk about the problem’s <em>objective function</em>, the
quantity that we are trying to optimize. Naturally, we’d like to
maximize profit. From the table, we know that we get $3,000 in profit
per batch of Product 1 and $5,000 per batch of Product 2. Thus the
formula</p>
<p><span class="math display">
3x_1 + 5x_2
</span></p>
<p>tells us (in thousands of dollars) how much profit we expect for a
given selection of <span class="math inline">x_1</span> and <span
class="math inline">x_2</span>.</p>
<p>Now, we can’t select <span class="math inline">x_1</span> and <span
class="math inline">x_2</span> to be arbitrarily high. We are restricted
by the available production time at each plant. So we will add
<em>constraints</em> relating to these availabilities. We know that each
batch of Product 1 requires 1 hour of time in Plant 1, while Product 2
does not require any time at Plant 1. So, knowing that 4 hours of
production time is available per week, the constraint associated with
production at Plant 1 is simply <span class="math inline">x_1 \leq
4</span>. Similarly, at Plant 2, Product 2 is the only one that requires
processing, at 2 hours per batch. With 12 hours per week available, the
constraint for Plant 2 becomes <span class="math inline">2x_2 \leq
12</span>.<a href="#fn10" class="footnote-ref" id="fnref10"
role="doc-noteref"><sup>10</sup></a></p>
<p>What about Plant 3? Both products require time at this facility, so
they could both contribute to the depletion of its 18 hours per week.
Every batch of Product 1 requires 3 hours, while every batch of Product
2 requires 2 hours. So the constraint imposed by Plant 3 is simply <span
class="math inline">3x_1 + 2x_2 &lt;= 18</span>.</p>
<p>Lastly, we know that <span class="math inline">x_1</span> and <span
class="math inline">x_2</span> cannot be negative (there is no way to
produce a negative number of products), so <span class="math inline">x_1
\geq 0</span> and <span class="math inline">x_2 \geq 0</span> must be
part of our formulation as well. Bringing it all together, we can write
the problem formulation as:</p>
<p><span id="eq:prototypeLp" class="eqnos"><span class="math display">
\begin{align*}
\text{max}&amp;&amp; 3x_1 + 5x_2 &amp; \\
\text{s.t.}&amp;&amp; x_1 &amp; \leq \ \ 4  \\
     &amp;&amp; 2x_2 &amp; \leq 12 \\
     &amp;&amp; 3x_1 + 2x_2 &amp; \leq 18 \\
     &amp;&amp; x_1,x_2 &amp; \geq \ \ 0
\end{align*}
</span><span class="eqnos-number">(1)</span></span></p>
<h2 data-number="4.2" id="lp-terminology"><span
class="header-section-number">4.2</span> LP terminology</h2>
<p>With this example in hand, let’s get back to some definitions. The
<strong>decision variables</strong> are the quantities we’re deciding
how to set. In our example these are <span
class="math inline">x_1</span> and <span class="math inline">x_2</span>,
the number of batches run per week for the two products. The
<strong>objective</strong> is the value we’d like to optimize, which in
the example is the profit equation <span class="math inline">3x_1 +
5x_2</span>. In this case we’d like to maximize the objective, but
minimization is possible as well. The <strong>constraints</strong> are
the limitations on how we set the decision variables, which in this case
is everything after the “s.t.”<a href="#fn11" class="footnote-ref"
id="fnref11" role="doc-noteref"><sup>11</sup></a>. Notice that the final
constraint, <span class="math inline">x_1,x_2\geq0</span>, is really two
constraints so this is abusing notation a bit. But these types of
constraints (called <strong>variable bound</strong> constraints, or in
this case <em>non-negativity</em> constraints since they restrict
variables to <span class="math inline">\geq0</span>) are often treated
separately in solution techniques, so it is common to see them grouped
or written slightly differently like this. We call the rest of the
constraints the <strong>functional constraints</strong>.</p>
<p>A <strong>solution</strong> to an LP is any specification of values
for the decision variables. And I do mean <em>any</em><a href="#fn12"
class="footnote-ref" id="fnref12" role="doc-noteref"><sup>12</sup></a>,
it doesn’t matter if the values imply a good objective value or even if
they satisfy the constraints. They are still called a solution. Hence
each of:</p>
<ul>
<li><span class="math inline">x_1=0, x_2=0</span></li>
<li><span class="math inline">x_1=-20, x_2=6</span></li>
<li><span class="math inline">x_1=2, x_2=3</span></li>
</ul>
<p>are all solutions to our sample problem, even though the second one
violates non-negativity.</p>
<p>A <strong>feasible solution</strong> is a solution that satisfies all
of the problem constraints. In contrast, an <strong>infeasible
solution</strong> is one that violates <em>at least one</em> constraint.
The <strong>feasible region</strong> is the set of all feasible
solutions. It is possible for a problem to have no feasible solutions,
in which case the problem itself is said to be
<strong>infeasible</strong>.</p>
<p>When solving an LP, the goal is to find an <strong>optimal
solution</strong>, a feasible solution that gives the most favorable
value<a href="#fn13" class="footnote-ref" id="fnref13"
role="doc-noteref"><sup>13</sup></a> of the objective function. Notice
we said <em>an</em> optimal solution, not <em>the</em> optimal solution,
as it is entirely possible for a problem to have more than one solution
attain the optimal value. It is also possible to have no optimal
solutions at all, as in the case of an infeasible problem. Another
situation with no optimal solution is an <strong>unbounded</strong>
problem, where the objective value can become arbitrarily favorable.</p>
<h2 data-number="4.3" id="lp-visualized"><span
class="header-section-number">4.3</span> LP visualized</h2>
<p>Let’s get hands-on again to see our new definitions in action. Since
our sample problem includes only two decision variables, we can
visualize what’s going on in a plot:</p>
<svg width="350" height="350" class="lpDraw" base="prototypeLp" altArgs="{&quot;choosePoints&quot;: true}">
Sorry, your browser does not support inline SVG.
</svg>
<p>Here we have a plot with <span class="math inline">x_1</span> on the
horizontal axis, <span class="math inline">x_2</span> on the vertical
axis, and a line drawn for each <strong>constraint boundary</strong>
(the line that forms the boundary of what is permitted by the
corresponding constraint) for the constraints of eq. <a
href="#eq:prototypeLp">1</a>. Moreover, if you hover over a constraint
boundary, the side of the line satisfied by the inequality is shaded
light gray<a href="#fn14" class="footnote-ref" id="fnref14"
role="doc-noteref"><sup>14</sup></a>. The feasible region is the portion
of the plot where all the constraints are satisfied, and it is plainly
visible as the gray-shaded region in the bottom-left. Such an
intersection of linear inequalities is called a
<strong>polyhedron</strong>, and in cases such as this where the
polyhedron is bounded (i.e. doesn’t go off to infinity in some
direction) we also call it a <strong>polytope</strong>.</p>
<p>If you click on the plot (or enter values in the text boxes) a
solution will be drawn. If the point is a feasible solution, it will be
colored black and the objective value at the solution is show below the
plot. Otherwise the solution is infeasible, the point will be colored
red, and the violated inequalities will flash.</p>
<p>How can we visualize the objective? Since the objective is given by
<span class="math inline">3x_1 + 5x_2</span>, any line we draw of the
form <span class="math inline">3x_1 + 5x_2 = Z</span> (for some number
<span class="math inline">Z</span>) will show the solutions that give
objective value <span class="math inline">Z</span>. You can try this
with the plot below: put your chosen <span class="math inline">Z</span>
value in the input box (or click on the plot to get a line going through
that point). The line will show up on the plot, and the intersection
with the feasible region (if any exists) will be highlighted. These
highlighted solutions each give objective value <span
class="math inline">Z</span>.</p>
<svg width="350" height="350" class="lpDraw" base="prototypeLp" altArgs="{&quot;chooseObjVals&quot;: true}">
Sorry, your browser does not support inline SVG.
</svg>
<h3 data-number="4.3.1" id="solving-an-lp-visually"><span
class="header-section-number">4.3.1</span> Solving an LP visually</h3>
<p>We actually have the tools to solve this problem now. For problems in
two dimensions, it is fairly straightforward to draw a graph and see
where the best solution is. This is not a good (or usually even
feasible) method in practice, but for a toy problem it can really help
build some intuition.</p>
<p>Let’s look back at the above plot. Since we’re maximizing, we’d like
to choose the largest <span class="math inline">Z</span> such that the
line intersects the feasible region. Let’s start with something too big,
say <span class="math inline">Z=50</span>. When we plot that, we see it
is way too high above the feasible region. So we can start moving it
lower. Maybe go to <span class="math inline">Z=40</span>. It’s still
completely above the feasible region, so that’s not it either. Now jump
to <span class="math inline">Z=30</span>. This intersects the plot, but
there is a section of the feasible region above the line, and hence
feasible solutions with a better objective value.</p>
<p>So keep searching. When you come to <span
class="math inline">Z=36</span> the situation looks different. The line
intersects the plot at a single point, <span class="math inline">x_1=2,
x_2=6</span>. If you move the objective up just a little bit, say to
36.1, you get no intersection with the feasible region<a href="#fn15"
class="footnote-ref" id="fnref15" role="doc-noteref"><sup>15</sup></a>.
Thus we know we’ve found the optimal solution<a href="#fn16"
class="footnote-ref" id="fnref16" role="doc-noteref"><sup>16</sup></a>,
and in this case it is unique.</p>
<h3 data-number="4.3.2" id="visualizing-other-scenarios"><span
class="header-section-number">4.3.2</span> Visualizing other
scenarios</h3>
<p>Let see some examples of the other scenarios we defined above. In
each case, we’ll take our initial model eq. <a
href="#eq:prototypeLp">1</a> and modify it to show the desired
property.</p>
<h4>
An infeasible problem
</h4>
<svg width="350" height="350" class="lpDraw" base="prototypeLp" altArgs="{&quot;addConstraints&quot;: [[[1, 3, 30, &quot;g&quot;], [5, 9.25]]], &quot;choosePoints&quot;: true}">
Sorry, your browser does not support inline SVG.
</svg>
<p>In this plot, we’ve added the constraint <span
class="math inline">x_1 + 3x_2 \geq 30</span>. All the points satisfying
this inequality are well above the previous feasible region, so no
solutions are feasible.</p>
<h4>
An unbounded problem
</h4>
<svg width="350" height="350" class="lpDraw" base="prototypeLp" altArgs="{&quot;removeConstraints&quot;: [0, 1], &quot;altFeasRegionTextPlace&quot;: [4.5, 3.5], &quot;chooseObjVals&quot;: true}">
Sorry, your browser does not support inline SVG.
</svg>
<p>Here we’ve removed two constraints, with the only one remaining being
<span class="math inline">2x_2 &lt;= 12</span>. We can see there is no
constraint on <span class="math inline">x_1</span> at all now, so we can
choose it arbitrarily large and still be in the feasible region<a
href="#fn17" class="footnote-ref" id="fnref17"
role="doc-noteref"><sup>17</sup></a>.</p>
<h4>
Multiple optima
</h4>
<svg width="350" height="350" class="lpDraw" base="prototypeLp" altArgs="{&quot;altObj&quot;: [6, 4], &quot;chooseObjVals&quot;: true}">
Sorry, your browser does not support inline SVG.
</svg>
<p>In this example, we’ve altered the objective function to <span
class="math inline">6x_1 + 4x_2</span> so that it has the same slope as
one of our constraints. We can see by moving the objective up and down
that the optimal solution comes at <span
class="math inline">Z=36</span>, where the objective line intersects an
entire face (bounding line) of the feasible region. Since any point on
that bounding line attains the optimal objective value, they are all
optimal solutions.</p>
<h2 data-number="4.4" id="solving-lps-with-software"><span
class="header-section-number">4.4</span> Solving LPs with software</h2>
<p>Let’s pause briefly now to explain, practically, how LPs can be
solved in the real world. By which I mean: if given an LP in practice,
what would you do to find the answer? I’m not talking about the theory
behind what LP solving software does (we’ll get the that later), just
how to <em>use</em> the software. This won’t be a comprehensive
discussion, really just giving you enough to solve our example LP. We’ll
expand on this discussion some when we get to modeling in the integer
programming section.</p>
<p>There are two key components to solving mathematical programming
problems in practice: the modeling language and the solver.</p>
<h3 data-number="4.4.1" id="modeling-languages"><span
class="header-section-number">4.4.1</span> Modeling languages</h3>
<p>The job of a modeling language is to take a model specification like
eq. <a href="#eq:prototypeLp">1</a> and turn it into something the
computer can understand and solve. Some popular modeling languages are
their own standalone software, such as <a
href="https://ampl.com/">AMPL</a> and <a
href="https://www.gams.com/">GAMS</a>. The modeling languages we’ll use
are instead shipped as Python<a href="#fn18" class="footnote-ref"
id="fnref18" role="doc-noteref"><sup>18</sup></a> libraries. Sometimes
these languages are built for use with a single solver, while others try
to be compatible with several different solvers.</p>
<h3 data-number="4.4.2" id="solvers"><span
class="header-section-number">4.4.2</span> Solvers</h3>
<p>The solver is the software that takes the modeled problem and applies
the necessary algorithms to solve it. There are several options here as
well. The best solvers all require paid licenses to use fully for
commercial purposes<a href="#fn19" class="footnote-ref" id="fnref19"
role="doc-noteref"><sup>19</sup></a>. The two biggest names in this
space are <a href="https://www.gurobi.com/">Gurobi</a> and <a
href="https://www.ibm.com/products/ilog-cplex-optimization-studio/cplex-optimizer">CPLEX</a>,
though <a
href="https://www.fico.com/en/products/fico-xpress-optimization">Xpress</a>
and <a href="https://www.shanshu.ai/copt/">COPT</a> are competitive as
well. There are also free, open-source options, but these generally
perform much worse than the commercial offerings. Some names in this
space are <a href="https://www.coin-or.org/">COIN-OR</a>, <a
href="https://www.gnu.org/software/glpk/">GLPK</a>, and <a
href="https://scipopt.org/">SCIP</a>.</p>
<h3 data-number="4.4.3" id="solving-our-lp-with-python"><span
class="header-section-number">4.4.3</span> Solving our LP with
Python</h3>
<p>In the following notebook, I show how we can model and solve our
sample LP in two different ways. The first way uses Gurobi as the solver
and its purpose-built Python library <code>gurobipy</code> as the
modeler. I should mention that since Gurobi is a commercial solver, we
need some sort of license for unrestricted use. However, we do get a
limited license automatically with the install of <code>gurobipy</code>
which is good for problems with up to 2000 variables and 2000 linear
constraints. This is pretty limiting for practical industry use, but
most everything we’ll do in this class will fall comfortably within
those bounds.</p>
<p>The second option is a fully open-source option using PuLP, a Python
modeling language maintained by COIN-OR. By default, this will use
COIN-OR’s linear programming solver CLP to solve the model. However, a
nice feature of PuLP is that it is solver-agnostic. This means that you
can use it to model your problem but switch between any of the popular
solvers (including the commercial ones). This is nice to avoid being
locked-in to a single solver. But it also may be slightly less
performant, or may lack some solver-specific features that come with a
solver’s built-in API.</p>
<script src="https://gist.github.com/9c7e1b589a3efb40590606ba6eed102f.js"></script>
<h3 data-number="4.4.4" id="modeldata-separation"><span
class="header-section-number">4.4.4</span> Model/data separation</h3>
<p>Our Python models from the last notebook certainly work for the
sample problem, but that’s about it. The real power of programming comes
when you can write one bit of code that can be applied in a wide range
of contexts.</p>
<p>Our sample LP is in the form of a <em>resource allocation
problem</em>, where the decision is how much to engage in a certain set
of possible activities, while staying within the bounds of the available
resources. We’d be better off to use Python to set the <em>model
logic</em> for such a problem, leaving placeholders where we can inject
the particular <em>problem data</em> for any given instance. We’ll do
that in the next notebook.</p>
<script src="https://gist.github.com/0a3d429db92daf96fac2eeb23a3197f7.js"></script>
<h2 data-number="4.5" id="sec:lpForms"><span
class="header-section-number">4.5</span> LP forms</h2>
<p>We’re <em>almost</em> ready to talk about algorithms for solving LPs,
but first we should make a note on some different forms LPs can take.
Crucially, it will turn out that all the forms we talk about here are,
in a sense, equivalent. Thus no matter the specifics of how an LP is
presented, we know we’ll be able to solve it using the general
methods.</p>
<h3 data-number="4.5.1" id="standard-form"><span
class="header-section-number">4.5.1</span> Standard form</h3>
<p>Our formulation of the sample LP in eq. <a
href="#eq:prototypeLp">1</a> is in what is known as <strong>standard
form</strong>. Generally, a linear program with <span
class="math inline">n</span> variables and <span
class="math inline">m</span> constraints is in standard form if it is
written as:</p>
<p><span id="eq:standardFormLp" class="eqnos"><span
class="math display">
\begin{align*}
\text{max}&amp;&amp; c_1x_1 + c_2x_2 + \cdots + c_nx_n &amp;&amp;
&amp;&amp; \\
\text{s.t.}&amp;&amp; a_{11}x_1 + a_{12}x_2 + \cdots + a_{1n}x_n
&amp;&amp; \leq &amp;&amp; b_1 \\
     &amp;&amp; a_{21}x_1 + a_{22}x_2 + \cdots + a_{2n}x_n &amp;&amp;
\leq &amp;&amp; b_2 \\
     &amp;&amp;                                            &amp;&amp;
\vdots &amp;&amp; \\
     &amp;&amp; a_{m1}x_1 + a_{m2}x_2 + \cdots + a_{mn}x_n &amp;&amp;
\leq &amp;&amp; b_m \\
     &amp;&amp; x_1, x_2, \cdots , x_n &amp;&amp; \geq &amp;&amp; 0
\end{align*}
</span><span class="eqnos-number">(2)</span></span></p>
<p>Where all the <span class="math inline">a</span>, <span
class="math inline">b</span>, and <span class="math inline">c</span>
values (known as the <strong>problem data</strong>) are real numbers.
Our sample problem, and many other practical LP problems, are naturally
formulated like this. But it might at first glance feel a bit limiting.
What if you’d rather minimize instead of maximizing? Or let your
variables take negative values? We’ll see in the following sections that
such considerations are indeed possible, and we can consider them in the
same framework as standard form problems.</p>
<h3 data-number="4.5.2" id="minimization-problems"><span
class="header-section-number">4.5.2</span> Minimization problems</h3>
<p>What if your optimization problem is a minimization problem and not a
maximization problem? For example, instead of maximizing profit, you’d
like to minimize cost? No worries, it is actually quite straightforward
to convert from minimization to maximization - just turn everything
negative! The minimum cost is the same as the maximum “negative cost”
<span class="math inline">(-1\cdot\text{cost})</span>. So</p>
<p><span class="math display">
\text{min}\ c_1x_1 + c_2x_2 + \cdots + c_nx_n
</span></p>
<p>is the same as</p>
<p><span class="math display">
\text{max}-c_1x_1 -c_2x_2 - \cdots -c_nx_n.
</span></p>
<p>Since the problem data can be any real number (so, in particular,
negative numbers are fine) this still follows the form of eq. <a
href="#eq:standardFormLp">2</a>.</p>
<h3 data-number="4.5.3" id="sec:lpConstraintTransform"><span
class="header-section-number">4.5.3</span> Different constraint
forms</h3>
<p>What if you wanted “greater than or equal” constraints instead of
“less than or equal” constraints? This is again another case of a sign
switch since if you take any inequality you can:</p>
<ul>
<li>multiply both sides by -1, and</li>
<li>switch the direction of the inequality</li>
</ul>
<p>to end up with a logically equivalent inequality<a href="#fn20"
class="footnote-ref" id="fnref20" role="doc-noteref"><sup>20</sup></a>.
Thus any inequality of the form:</p>
<p><span class="math display">
a_{i1}x_1 + a_{i2}x_2 + \cdots + a_{in}x_n \geq b_i
</span></p>
<p>can be written as</p>
<p><span class="math display">
-a_{i1}x_1 - a_{i2}x_2 - \cdots - a_{in}x_n \leq -b_i
</span></p>
<p>which brings us back into line with the standard form inequalities in
eq. <a href="#eq:standardFormLp">2</a>.</p>
<p>What about equality constraints? That is, constraints of the form</p>
<p><span class="math display">
a_{i1}x_1 + a_{i2}x_2 + \cdots + a_{in}x_n = b_i.
</span></p>
<p>Can these be converted into standard form? The answer is yes, but it
comes at the cost of an extra constraint in the formulation. Because
using the above constraint has the same effect as using these two in
combination:</p>
<p><span class="math display">
a_{i1}x_1 + a_{i2}x_2 + \cdots + a_{in}x_n \leq b_i \\
a_{i1}x_1 + a_{i2}x_2 + \cdots + a_{in}x_n \geq b_i
</span></p>
<p>Now, that second inequality does not fit in standard form since it is
a “<span class="math inline">\geq</span>” constraint, but we already
know how to convert it. So the final standard-form-conforming
formulation is:</p>
<p><span class="math display">
a_{i1}x_1 + a_{i2}x_2 + \cdots + a_{in}x_n \leq b_i \\
-a_{i1}x_1 - a_{i2}x_2 - \cdots - a_{in}x_n \leq -b_i
</span></p>
<p>Great, so we can go from equality constraints to inequality
constraints, but what about the other way? That is possible too, but
this time we’ll need to add a <em>variable</em> to the formulation. In
particular, to convert the inequality</p>
<p><span class="math display">
a_{i1}x_1 + a_{i2}x_2 + \cdots + a_{in}x_n \leq b_i
</span></p>
<p>to equality form, we’ll add a so-called <strong>slack
variable</strong> <span class="math inline">s_i</span>. We’ll enforce
<span class="math inline">s_i\geq0</span> and rewrite the constraint
as</p>
<p><span class="math display">
a_{i1}x_1 + a_{i2}x_2 + \cdots + a_{in}x_n + s_i = b_i.
</span></p>
<p>This works since, for any selection of the <span
class="math inline">x</span> values that satisfies the inequality, we
can simply select the value of <span class="math inline">s_i</span> as
the difference between <span class="math inline">b_i</span> and the
<span class="math inline">a_{i1}x_1 + a_{i2}x_2 + \cdots +
a_{in}x_n</span>, i.e. the <em>slack</em> in the constraint. Going the
other way, any variable selections that satisfy the equality will also
satisfy the inequality since, by rearranging the equality, we get</p>
<p><span class="math display">
a_{i1}x_1 + a_{i2}x_2 + \cdots + a_{in}x_n = b_i - s_i
</span></p>
<p>and <span class="math inline">s_i</span> is non-negative, so the
left-hand side is less than (or equal to) <span
class="math inline">b_i</span>.</p>
<h3 data-number="4.5.4" id="sec:lpVariableBoundTransform"><span
class="header-section-number">4.5.4</span> Variable bounds</h3>
<p>In the standard form problem, we enforce that all of our variables
are non-negative. But what if we don’t want any explicit bounds on the
variables? Is this a different class of problems? As it turns out, we
can freely switch back and forth between non-negative variables and
these so-called <strong>unrestricted</strong> or <strong>free
variables</strong>.</p>
<p>How do we do the transformations? The first direction is
straightforward; say you have a formulation with non-negative variables
and you’d like to remove the variable bounds. Well, we still have the
functional constraints, where we are allowed to use inequalities. So
we’ll “remove” the variable bound constraint <span
class="math inline">x_j\geq0</span> by creating a new functional
constraint</p>
<p><span class="math display">
a_1x_1 + \cdots + a_jx_j + \cdots + a_nx_n \leq b
</span></p>
<p>where <span class="math inline">b=0</span>, <span
class="math inline">a_j=-1</span>, and all other coefficients equal
<span class="math inline">0</span> (i.e. <span
class="math inline">-x_j\leq0\Leftrightarrow x_j\geq 0</span>).</p>
<p>Now the less obvious transformation. Say we have a formulation where
the variable <span class="math inline">x_j</span> is unrestricted. How
do we convert to non-negative variables? One way is to define two more
variables, call them <span class="math inline">w_j</span> and <span
class="math inline">z_j</span>, which will be our new non-negative
variables. What we’ll do is simply replace <span
class="math inline">x_j</span> with <span
class="math inline">w_j-z_j</span>, so that the constraints become</p>
<p><span class="math display">
a_{i1}x_1 + \cdots + a_{ij}w_j - a_{ij}z_j + \cdots + a_{in}x_n \leq b_i
</span></p>
<p>for each <span class="math inline">i</span><a href="#fn21"
class="footnote-ref" id="fnref21" role="doc-noteref"><sup>21</sup></a>,
and a similar replacement is done in the objective function.</p>
<h3 data-number="4.5.5" id="recap-of-allowed-forms"><span
class="header-section-number">4.5.5</span> Recap of allowed forms</h3>
<p>As a recap: we defined the standard form LP where the objective is
maximized, the functional constraints are <span
class="math inline">\leq</span> inequalities, and variables are
non-negative. But it turns out there are several equivalent ways to
formulate LPs, namely:</p>
<ul>
<li>Objectives can be either minimized or maximized.</li>
<li>Constraints can be in <span class="math inline">\leq</span>, <span
class="math inline">\geq</span>, or <span class="math inline">=</span>
form.</li>
<li>Variables may be bounded or not.</li>
</ul>
<p>Crucially, any of these forms can be transformed into any of the
others, so no matter how we specify a particular LP, any of the results
and techniques we discuss here apply!</p>
<h3 data-number="4.5.6" id="different-notation"><span
class="header-section-number">4.5.6</span> Different notation</h3>
<p>Last up for this section, let’s discuss notation. I don’t know about
you, but I get a little overwhelmed when I look at formulations like
eq. <a href="#eq:standardFormLp">2</a>. There’s a lot to look at there,
and while I think it’s good initially to see things written in full
detail with simple notation like this, returns begin diminishing
quickly. Especially in a case like this where there’s a lot of
repetition with minimal changes from line to line.</p>
<p>So, from here on out and where appropriate, I’ll start using more
concise notation. For example, eq. <a href="#eq:standardFormLp">2</a>
can be written more concisely like so:</p>
<p><span class="math display">
\begin{align*}
\text{max}&amp;&amp; \sum_{j=1}^n c_jx_j    &amp; \\
\text{s.t.}&amp;&amp; \sum_{j=1}^n a_{ij}x_j &amp; \leq b_i\quad \forall
i\in\{1,...,m\} \\
     &amp;&amp; x_j                    &amp; \geq 0_i\quad \forall
j\in\{1,...,n\}
\end{align*}
</span></p>
<p>This looks much cleaner to my eyes, and each line communicates
different important information about the formulation. But to benefit
from the compactness, one needs to be familiar with the notation used. I
assume everyone reading this has seen the summation notation <span
class="math inline">\sum</span> before, but some other notation (set
inclusion <span class="math inline">\in</span> and “for all” <span
class="math inline">\forall</span> in particular) may be new. And
sometimes new is intimidating. But fear not! These things get clearer
and clearer the more you see them, and I think the benefit is worth it.
There is a section in the appendix (section <a
href="#sec:symbols">5.1</a>) dedicated to special symbols. Beyond that,
if you’re ever confused about something, you can always ask me!</p>
<p>We’ll see more notation like the above as we formulate more specific
problems, but for much of the theory sections to come I actually much
prefer matrix notation. You should already be familiar with linear
algebra (section <a href="#sec:linearAlgebra">5.2</a> in the appendix
gives a brief review), so you should be able to notice how matrix
algebra fits nicely with the formulations we’ve already given. For some
<span class="math inline">m\times n</span> matrix <span
class="math inline">\mathbf{A}</span> and <span
class="math inline">n</span> vector <span
class="math inline">\mathbf{x}</span>, if we multiply them we have:</p>
<p><span class="math display">
\begin{align*}
\mathbf{A}\mathbf{x}&amp;=\begin{bmatrix}
    a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \\
    a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n} \\
    \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
    a_{m1} &amp; a_{m2} &amp; \cdots &amp; a_{mn} \\
\end{bmatrix}\begin{bmatrix}
    x_1 \\ x_2 \\ \vdots \\ x_n
\end{bmatrix}\\
&amp;=\begin{bmatrix}
    a_{11}x_1 + a_{12}x_2 + \cdots + a_{1n}x_n \\
    a_{21}x_1 + a_{22}x_2 + \cdots + a_{2n}x_n \\
    \vdots \\
    a_{m1}x_1 + a_{m2}x_2 + \cdots + a_{mn}x_n \\
\end{bmatrix}
\end{align*}
</span></p>
<p>which looks just like the constraint section of the standard form LP
eq. <a href="#eq:standardFormLp">2</a>. Due to the conciseness, my
favorite notation for the standard form LP is</p>
<p><span id="eq:standardFormLpMatrix" class="eqnos"><span
class="math display">
\begin{align*}
\text{max}&amp;&amp; \mathbf{c}\mathbf{x}\\
\text{s.t.}&amp;&amp; \mathbf{A}\mathbf{x}&amp;\leq\mathbf{b}\\
     &amp;&amp; \mathbf{x}&amp;\geq\mathbf{0}
\end{align*}
</span><span class="eqnos-number">(3)</span></span></p>
<p>Much nicer on the eyes, right!</p>
<p>Further, you may have noticed that though we’ve devoted significant
time to it already, we haven’t formally defined linear programming yet!
I was waiting for this moment to do so. A <strong>linear
program</strong> is an optimization problem in the form of eq. <a
href="#eq:standardFormLpMatrix">3</a>.</p>
<h2 data-number="4.6" id="the-simplex-method"><span
class="header-section-number">4.6</span> The simplex method</h2>
<p>We’re just about ready to talk about LP solving algorithms, and we’re
of course starting with the <strong>simplex method</strong> (also
sometimes called the <strong>simplex algorithm</strong>). Arguably the
most important breakthrough in the history of OR was the development of
the simplex method by George Dantzig<a href="#fn22" class="footnote-ref"
id="fnref22" role="doc-noteref"><sup>22</sup></a> during the late
1940s<a href="#fn23" class="footnote-ref" id="fnref23"
role="doc-noteref"><sup>23</sup></a>. It was perhaps the first practical
algorithm developed for linear programming, and it continues to be the
workhorse in linear and integer programming solvers today<a href="#fn24"
class="footnote-ref" id="fnref24"
role="doc-noteref"><sup>24</sup></a>.</p>
<h3 data-number="4.6.1" id="corner-point-solutions"><span
class="header-section-number">4.6.1</span> Corner-point solutions</h3>
<p>Before we get to the algorithm itself, let’s take a moment to dwell
on some geometric insights the method relies on. We’ll return to our
sample problem eq. <a href="#eq:prototypeLp">1</a> and once again we’ll
graph it below.</p>
<svg width="350" height="350" class="lpDraw" base="prototypeLp" altArgs="{&quot;showVertices&quot;: true}">
Sorry, your browser does not support inline SVG.
</svg>
<p>This time we’ve also plotted the solutions in the corners of the
feasible region, because they are important to the simplex algorithm. We
call these solutions <strong>corner-point feasible (CPF)
solutions</strong><a href="#fn25" class="footnote-ref" id="fnref25"
role="doc-noteref"><sup>25</sup></a> or <strong>vertices</strong><a
href="#fn26" class="footnote-ref" id="fnref26"
role="doc-noteref"><sup>26</sup></a>, which are feasible solutions that
come at the intersection of two constraint boundaries (in the general
case, for LPs in standard form eq. <a href="#eq:standardFormLp">2</a>
with <span class="math inline">n</span> decision variables, the CPF
solutions come at the intersection of <span class="math inline">n</span>
constraints boundaries).</p>
<p>The simplex algorithm makes use of the following key fact of linear
programs:</p>
<div id="thm:cornerPointOpt" class="theorem">
<p>If a linear program has an optimal solution (i.e. not unbounded or
infeasible), then it has an optimal solution that is a corner-point
solution.</p>
</div>
<div class="proof" for="thm:cornerPointOpt" data-placement="appendix">
<p>We won’t actually give a full proof of this theorem, instead we’ll
only consider the case of a standard form LP (eq. <a
href="#eq:standardFormLpMatrix">3</a>) with only two decision variables.
Those of you that are familiar with <a
href="https://en.wikipedia.org/wiki/Mathematical_induction">proofs by
induction</a> may be able to see how to generalize this to any number of
variables.</p>
<p>In two dimensions we can visualize this, so let’s continue to use the
sample LP of eq. <a href="#eq:prototypeLp">1</a> as our example. Any
feasible solution to a two-dimensional LP must fall under exactly one of
these categories:</p>
<ol type="1">
<li>An interior solution (not on any constraint boundaries).</li>
<li>On a single constraint boundary.</li>
<li>A corner-point feasible (CPF) solution (i.e. at the intersection of
two constraint boundaries).</li>
</ol>
<p>What we can show is that for any solution of type 1 or 2, we can find
a CPF solution with equal or greater objective value, and we will
illustrate this in the plot below. To that end, suppose we have some
solutions <span class="math inline">\mathbf{z}</span> on the interior of
the feasible region, and <span class="math inline">\mathbf{y}</span>
that lies on a single constraint boundary.</p>
<svg width="350" height="350" class="lpDraw" base="prototypeLp" altArgs="{&quot;extraPoints&quot;: [[2, 1], [3, 4.5]], &quot;extraLines&quot;: [[2, 1, 3, 1.5, {&quot;style&quot;: &quot;stroke-width:2pt;stroke:black&quot;, &quot;marker-end&quot;: &quot;url(#blackArrowMarker)&quot;}], [3, 4.5, 2.5, 5.25, {&quot;style&quot;: &quot;stroke-width:2pt;stroke:black&quot;, &quot;marker-end&quot;: &quot;url(#blackArrowMarker)&quot;}]], &quot;extraMathText&quot;: [[&quot;y&quot;, 3.25, 5, {&quot;coordToPix&quot;: true}], [&quot;z&quot;, 1.75, 1.75, {&quot;coordToPix&quot;: true}], [&quot;v&quot;, 2, 5.75, {&quot;coordToPix&quot;: true}], [&quot;u&quot;, 3.25, 1.75, {&quot;coordToPix&quot;: true}]]}">
Sorry, your browser does not support inline SVG.
</svg>
<p>Let <span class="math inline">\mathbf{v}</span> be a (unit) vector
that points in the same direction as the constraint boundary that <span
class="math inline">\mathbf{y}</span> is on. Let <span
class="math inline">\mathbf{c}</span> be the vector of objective
function coefficients (so in our sample LP we would have <span
class="math inline">\mathbf{c}=\begin{bmatrix}3\\5\end{bmatrix}</span>).
The objective value at solution <span
class="math inline">\mathbf{y}</span> is <span
class="math inline">\mathbf{y}\mathbf{c}</span>. In contrast, if we move
some amount <span class="math inline">\delta</span> from <span
class="math inline">\mathbf{y}</span> along direction <span
class="math inline">\mathbf{v}</span>, the objective value is (due to
distributivity of matrix operations) <span
class="math inline">(\mathbf{y} + \delta\mathbf{v})\mathbf{c}=
\mathbf{y}\mathbf{c}+ \delta\mathbf{v}\mathbf{c}</span>.</p>
<p>If <span class="math inline">\mathbf{v}\mathbf{c}\geq0</span>, then
moving from <span class="math inline">\mathbf{y}</span> along the
constraint boundary in the direction of <span
class="math inline">\mathbf{v}</span> improves the objective value. So
we can continue in that direction until we meet another constraint,
yielding a CPF solution with greater-or-equal objective value than <span
class="math inline">y</span>. If, on the other hand, <span
class="math inline">\mathbf{v}\mathbf{c}&lt;0</span>, then we can move
in the direction of <span class="math inline">-\mathbf{v}</span> to a
CPF solution with greater objective value than <span
class="math inline">\mathbf{y}</span>. So either way, there is some CPF
solution with objective value at least as good as <span
class="math inline">\mathbf{y}</span>.</p>
<p>The proof for the interior point <span
class="math inline">\mathbf{z}</span> is very similar. Select some
direction <span class="math inline">\mathbf{u}</span>, and then travel
from <span class="math inline">\mathbf{z}</span> along directions <span
class="math inline">\mathbf{u}</span> or <span
class="math inline">\mathbf{u}</span> until you hit a constraint
boundary. One of these points will yield an objective value at least as
good as <span class="math inline">\mathbf{z}</span>, and it will be on
either:</p>
<ul>
<li>The intersection of two constraints, in which case we’ve found the
CPF solution with at least as good a value as <span
class="math inline">\mathbf{z}</span>.</li>
<li>A single constraint, in which case we can repeat the procedure shown
above for <span class="math inline">\mathbf{y}</span> to find the CPF
solution.</li>
</ul>
<p>In either case, we’ve found our required CPF solution, thus the proof
is complete.</p>
</div>
<p>Thanks to this theorem<a href="#fn27" class="footnote-ref"
id="fnref27" role="doc-noteref"><sup>27</sup></a> we know that we only
need to check CPF solutions when solving an LP! We make use of this fact
during the simplex method, which only checks CPF solutions. We won’t
check <em>every</em><a href="#fn28" class="footnote-ref" id="fnref28"
role="doc-noteref"><sup>28</sup></a> CPF solution, though. The key to
simplex is that we jump from one CPF solution to the next while taking
care that each move improves the objective value.</p>
<p>In fact, the set of solutions we can move to in any iteration is
limited to only the solutions that are adjacent to the current solution.
In a standard-form LP with <span class="math inline">n</span> decision
variables, two CPF solutions are <strong>adjacent</strong> if they share
<span class="math inline">n-1</span> constraint boundaries. Recall that
CPF solutions lie at the intersection of <span
class="math inline">n</span> constraint boundaries, so we can also say
that two adjacent CPF solutions share all but one boundary in
common.</p>
<p>We have all the definitions now to describe simplex in a nutshell:
The simplex method solves a linear programming problem by successively
moving from one CPF solution to another, adjacent CPF solution, making
sure each such move improves the objective function, until no such
improvement exists<a href="#fn29" class="footnote-ref" id="fnref29"
role="doc-noteref"><sup>29</sup></a>.</p>
<h3 data-number="4.6.2" id="sec:simplexVisualized"><span
class="header-section-number">4.6.2</span> Simplex visualized</h3>
<p>Now that we have the basic idea, let’s go ahead and walk through the
steps of the simplex algorithm. We won’t go fully general on our first
time through, though. Let’s again consider our sample problem of eq. <a
href="#eq:prototypeLp">1</a>, which we’ve plotted again below. This
time, though, the plot contains some controls that let us step through
the simplex method one iteration at a time. I should stress that the
simplex method does not work <em>exactly</em> like what we’ll talk
through below, but all the intuitions are the same and the exercise is,
I think, a useful one.</p>
<svg width="350" height="350" class="lpDraw" base="prototypeLp" altArgs="{&quot;simplexStart&quot;: [0, 0]}">
Sorry, your browser does not support inline SVG.
</svg>
<p>The first step is to find an initial CPF solution. In our case (and
lots of practical instances too) the solution <span
class="math inline">(0, 0)</span> is a feasible solution, and a corner
point as well. It’s not a particularly desirable solution in the context
of our problem since it brings us no profit, but we don’t care about
desirability yet.</p>
<p>After initialization, we begin the algorithm’s main loop. First we
have to determine if there are any adjacent CPF solutions with improving
objective value. Recall that an adjacent solution will share <span
class="math inline">n-1</span> constraint boundaries with the current
solution. Since we’re in two dimensions, the adjacent solutions share
one constraint boundary with the current solution. To find the adjacent
solutions, we travel out from <span class="math inline">(0,0)</span>
along the two boundary lines it sits on, which in this case are the two
axes. Thus the two directions we can move in are <span
class="math inline">(1,0)</span> and <span
class="math inline">(0,1)</span>.</p>
<p>How do we know if a solution in any particular direction is improving
the objective value? Let’s consider the direction <span
class="math inline">(1,0)</span>. Since we’re moving from <span
class="math inline">(0,0)</span> to some point in the direction of <span
class="math inline">(1,0)</span>, the resulting solution will look like
<span class="math inline">(0,0) + \alpha(1,0)</span> for some number
<span class="math inline">\alpha</span>. The objective value of any
point <span class="math inline">\mathbf{x}</span> is <span
class="math inline">\mathbf{c}\mathbf{x}</span> where <span
class="math inline">\mathbf{c}</span> is the vector of objective
coefficients (which is <span class="math inline">(3,5)</span> in our
sample problem). So the objective value of <span
class="math inline">(0,0) + \alpha(1,0)</span> is</p>
<p><span class="math display">
([0\ 0] + \alpha[1\ 0])\begin{bmatrix}3\\5\end{bmatrix}
</span></p>
<p>and since matrix multiplication distributes through addition, this is
the same as</p>
<p><span class="math display">
[0\ 0]\begin{bmatrix}3\\5\end{bmatrix} + \alpha[1\
0]\begin{bmatrix}3\\5\end{bmatrix}.
</span></p>
<p>That first term, <span class="math inline">[0\
0]\begin{bmatrix}3\\5\end{bmatrix}</span>, is just the objective value
associated with the current solution <span
class="math inline">(0,0)</span>. So the second term <span
class="math inline">\alpha[1\ 0]\begin{bmatrix}3\\5\end{bmatrix}</span>,
is the <em>improvement</em> associated with the move.</p>
<p>We have two directions in which we can move, <span
class="math inline">(1,0)</span> and <span
class="math inline">(0,1)</span>. To keep things standardized we’ll want
to re-scale our directions to be unit vectors (i.e. vectors with length
one), but in this case they’re already unit vectors. The improvements
associated with unit moves in these directions are <span
class="math inline">[1\ 0]\begin{bmatrix}3\\5\end{bmatrix}=3</span> and
<span class="math inline">[0\
1]\begin{bmatrix}3\\5\end{bmatrix}=5</span>. These are both positive
numbers, and since we’re trying to maximize the objective value, that
means that solutions in either direction are improvements.</p>
<p>All that information is summarized in the table below the plot. The
two directions are listed, as well as the per-unit change in objective
function (under the heading <span class="math inline">\Delta</span> Obj
/ Unit<a href="#fn30" class="footnote-ref" id="fnref30"
role="doc-noteref"><sup>30</sup></a>). Since both directions improve the
objective, you have the option to choose either one using the checkboxes
in the final column.</p>
<p>Let’s go ahead and choose the <span class="math inline">(0,1)</span>
direction, since it gives the highest per-unit objective change<a
href="#fn31" class="footnote-ref" id="fnref31"
role="doc-noteref"><sup>31</sup></a>. Press the forward button on the
plot, and you’ll see it finds the adjacent solution in that direction,
<span class="math inline">(0,6)</span>, and the directions to its
adjacent solutions. But only one of the directions is improving, so we
choose to move in that direction <span class="math inline">(1,0)</span>
to the adjacent CPF solution <span class="math inline">(2,6)</span>. At
this point none of the adjacent directions are improvements, so the
current point is optimal and the algorithm is finished.</p>
<p>One thing to note before we move on: All the information we gather
during an iteration is in some sense “local” to the current CPF
solution. We compute only the <em>directions</em> to the neighboring
solutions, not the actual solutions themselves. Only once we decide on a
direction do we find the actual CPF solution. This is because finding
the solutions is much more expensive computationally speaking, and we’d
like to defer that step and only compute solutions when necessary. This
isn’t such a big deal on a small, two-dimensional example like this, but
in larger scale instances this saves a good amount of time.</p>
<h3 data-number="4.6.3" id="augmented-form-and-basic-solutions"><span
class="header-section-number">4.6.3</span> Augmented form and basic
solutions</h3>
<p>We’ll return again to our sample problem from eq. <a
href="#eq:prototypeLp">1</a>. The first thing we’ll need to do is change
the form of the problem. While we modeled the sample problem in standard
form eq. <a href="#eq:standardFormLpMatrix">3</a>, the simplex method
requires constraints in equality form (along with the non-negative
variables and maximizing the objective). We call this the
<strong>augmented form</strong> linear program, which we write as</p>
<p><span id="eq:augmentedFormLpMatrix" class="eqnos"><span
class="math display">
\begin{align*}
\text{max}&amp;&amp; \mathbf{c}\mathbf{x}\\
\text{s.t.}&amp;&amp; \mathbf{A}\mathbf{x}&amp;=\mathbf{b}\\
     &amp;&amp; \mathbf{x}&amp;\geq\mathbf{0}
\end{align*}
</span><span class="eqnos-number">(4)</span></span></p>
<p>To transform our sample problem into augmented form, we’ll steal a
trick from section <a href="#sec:lpConstraintTransform">4.5.3</a>. We’ll
turn the inequality constraints into equations by adding a slack
variable to each constraint, yielding the following formulation:</p>
<p><span class="math display">
\begin{align*}
\text{max}&amp;&amp; 3x_1 + 5x_2 &amp; \\
\text{s.t.}&amp;&amp; x_1 + x_3 &amp; = \ \ 4  \\
     &amp;&amp; 2x_2 + x_4 &amp; = 12 \\
     &amp;&amp; 3x_1 + 2x_2 + x_5 &amp; = 18 \\
     &amp;&amp; x_1,x_2,x_3,x_4,x_5 &amp; \geq \ \ 0
\end{align*}
</span></p>
<p>We call <span class="math inline">x_3</span> the <em>slack
variable</em> for the first constraint because its value in a feasible
solution tells you how far away the solution’s values for <span
class="math inline">x_1</span> and <span class="math inline">x_2</span>
were from the constraint boundary in eq. <a
href="#eq:prototypeLp">1</a>.</p>
<p>Simplex involves lots of matrix manipulations, so let’s rewrite this
in matrix form. Following usual convention, we’ll also add an extra
variable <span class="math inline">Z</span> which is equal to the
problem’s objective value. So in this case, we have</p>
<p><span class="math display">
Z = 3x_1 + 5x_2.
</span></p>
<p>Additionally, we’ll go rogue a bit and neglect writing the
non-negativity constraints. They’re still there, but the simplex
algorithm will take care of them implicitly. So in matrix form, our
problem looks like:</p>
<p><span class="math display">
\begin{bmatrix}
1 &amp; -3 &amp; -5 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 1  &amp;  0 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 0  &amp;  2 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 3  &amp;  2 &amp; 0 &amp; 0 &amp; 1 \\
\end{bmatrix}
\begin{bmatrix}
Z \\ x_1 \\ x_2 \\ x_3 \\ x_4 \\ x_5
\end{bmatrix}
=
\begin{bmatrix}
0 \\ 4 \\ 12 \\ 18
\end{bmatrix}
</span></p>
<p>Recall in section <a href="#sec:simplexVisualized">4.6.2</a> we made
use of <span class="thmRef" for="thm:cornerPointOpt"></span> to solve
the LP, jumping from CPF solution to CPF solution while increasing the
objective value at every step. We’ll do similar algebraically now, but
instead of a CPF solution (which made sense in the standard-form world
of eq. <a href="#eq:standardFormLpMatrix">3</a>) we’ll make use of
<strong>basic feasible (BF) solutions</strong>, the augmented-form
analogue. Indeed, the only real difference between corner-point and
basic solutions is whether or not the slack variables are included.</p>
<p>That said, basic solutions have their own important properties.
Studying the system of equations in the above matrix, we see that we
have 5 variables but only 3 (linearly independent) constraints. As you
may recall from linear algebra class, this means we have 2 <em>degrees
of freedom</em>, and thus two of the variables may be set arbitrarily
while solving the system. In the simplex method, these two variables
will take the value 0. The variables set to 0 are called the
<strong>non-basic variables</strong>. We can then solve the system of
equations to retrieve values for the other 3 variables, which are called
the <strong>basic variables</strong>, and collectively the
<strong>basis</strong>. Together, the values of the basic and non-basic
variables make up a <strong>basic solution</strong>.</p>
<p>The key properties of basic solutions are the following (quoting from
<span class="citation" data-cites="classText">Hillier and Lieberman (<a
href="#ref-classText" role="doc-biblioref">2021</a>)</span>):</p>
<blockquote>
<ul>
<li>Each variable is designated as either a nonbasic variable or a basic
variable.</li>
<li>The number of basic variables equals the number of functional
constraints (now equations). Therefore, the number of nonbasic variables
equals the total number of variables minus the number of functional
constraints.</li>
<li>The nonbasic variables are set equal to zero.</li>
<li>The values of the basic variables are obtained as the simultaneous
solution of the system of equations (functional constraints in augmented
form).</li>
<li>If the basic variables satisfy the non-negativity constraints, the
basic solution is a BF solution.</li>
</ul>
</blockquote>
<p>Two BF solutions are said to be <strong>adjacent</strong> if <em>all
but one</em> of their non-basic variables are the same. Note that this
means also that all but one of their basic variables are the same. Also
note that we don’t mean that these basic variables take on the same
<em>values</em>, just that the identity of the variables are the same.
So e.g. one basic solution with basic variables <span
class="math inline">x_1, x_2</span> and <span
class="math inline">x_3</span> is adjacent to another solution with
basic variables <span class="math inline">x_1, x_2, x_4</span>, no
matter the values taken by those variables in the respective
solutions.</p>
<h3 data-number="4.6.4" id="sec:simplexExample"><span
class="header-section-number">4.6.4</span> Solving the sample LP with
simplex</h3>
<p>To recap with our new terminology, the goal of the simplex method is
to take an LP in augmented form, and iteratively move from one BF
solution to another, adjacent BF solution while improving the objective
value at every step. We’ve already converted our sample problem to
augmented form, summarized by the following matrix:</p>
<p><span id="eq:simplexExampleMatrix1" class="eqnos"><span
class="math display">
\begin{bmatrix}
1 &amp; -3 &amp; -5 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 1  &amp;  0 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 0  &amp;  2 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 3  &amp;  2 &amp; 0 &amp; 0 &amp; 1 \\
\end{bmatrix}
\begin{bmatrix}
Z \\ x_1 \\ x_2 \\ x_3 \\ x_4 \\ x_5
\end{bmatrix}
=
\begin{bmatrix}
0 \\ 4 \\ 12 \\ 18
\end{bmatrix}
</span><span class="eqnos-number">(5)</span></span></p>
<h4>
Find an initial BF Solution
</h4>
<p>We’d like to start iterating between adjacent BF solutions, but to do
that we need a BF solution to start with. We’ll go into more details on
how to find initial BF solutions later in section <a
href="#sec:lpOtherConsiderations">4.6.7</a>, but for now let’s notice
that using the slack variables as the initial basis will make this
system very easy to solve. Why? Since <span
class="math inline">x_1</span> and <span class="math inline">x_2</span>
are non-basic, we set their values to 0. Thus the system eq. <a
href="#eq:simplexExampleMatrix1">5</a> reduces to:</p>
<p><span class="math display">
\begin{bmatrix}
1 &amp; -3 &amp; -5 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 1  &amp;  0 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 0  &amp;  2 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 3  &amp;  2 &amp; 0 &amp; 0 &amp; 1 \\
\end{bmatrix}
\begin{bmatrix}
Z \\ 0 \\ 0 \\ x_3 \\ x_4 \\ x_5
\end{bmatrix}
=
\begin{bmatrix}
0 \\ 4 \\ 12 \\ 18
\end{bmatrix}
</span></p>
<p>or, equivalently:</p>
<p><span class="math display">
\begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1 \\
\end{bmatrix}
\begin{bmatrix}
Z \\ x_3 \\ x_4 \\ x_5
\end{bmatrix}
=
\begin{bmatrix}
0 \\ 4 \\ 12 \\ 18
\end{bmatrix}
</span></p>
<p>So the initial BF solution is <span class="math inline">(x_1, x_2,
x_3, x_4, x_5)</span> = <span class="math inline">(0, 0, 4, 12,
18)</span>, yielding objective value <span
class="math inline">Z=0</span>.</p>
<p>This BF solution was easy to solve for because of how the system was
set up. The portion of the matrix corresponding to the basic variables
was essentially an identity matrix, so we just needed to read the values
off the right-hand side. Indeed, as we move from one BF solution to
another, we will explicitly manipulate the matrix (using basic row
operations, as in section <a
href="#sec:elementaryRowOperations">5.2.6</a>) to yield an identity
structure in the basic columns.</p>
<p>But we’re not there yet. We just have an initial BF solution, and
need to figure out how to move to an adjacent one while improving the
objective value. Recall that adjacent solutions share all their basic
variables in common except 1, so the decisions to make are</p>
<ol type="1">
<li>Does an improving solution exist?</li>
<li>If so, which of the current non-basic variables should we move into
the basis?</li>
<li>In light of the last decision, which of the current basic variables
should we remove from the basis?</li>
</ol>
<h4>
Optimality test
</h4>
<p>To decide whether an improving adjacent solution exists, we’ll take a
look at the top row of our matrix eq. <a
href="#eq:simplexExampleMatrix1">5</a>, which we set up to track the
objective value <span class="math inline">Z</span>. When multiplied by
the variable vector, that top row currently reads as <span
class="math inline">Z - 3x_1 - 5x_2 = 0</span>, simply a rearranging of
the usual objective <span class="math inline">Z = 3x_1 + 5x_2</span>.
Thus a negative value in the top row indicates that including that
variable in the basis will improve the objective value. Since we have
negative values in the top row, we conclude that the current solution is
not optimal.</p>
<h4>
Determine the incoming variable
</h4>
<p>Since both <span class="math inline">x_1</span> and <span
class="math inline">x_2</span> have negative values in the objective
row, we now have two choices of incoming basic variables that will
improve the objective value. As we did in section <a
href="#sec:simplexVisualized">4.6.2</a>, we will choose the variable
that gives the highest such improvement per unit change in the variable,
which in this case is <span class="math inline">x_2</span> (which has a
coefficient of -5 in the top row, vs. -3 for <span
class="math inline">x_1</span>).</p>
<h4>
Determine the outgoing variable
</h4>
<p>We’ve decided that we want <span class="math inline">x_2</span> to
enter the basis, i.e. we’d like its value to increase from 0 in the
current solution to some positive value in the next solution. What
effect does increasing <span class="math inline">x_2</span> have on the
constraints? All of the equations are currently satisfied, so changing
the value of <span class="math inline">x_2</span> means that we must
change the values of other variables to compensate. Luckily, the way the
matrix is set up, each constraint has only one basic variable with a
non-zero coefficient. For example, the third row of eq. <a
href="#eq:simplexExampleMatrix1">5</a>, when multiplied out, reads:</p>
<p><span class="math display">
2x_2 + x_4 = 12.
</span></p>
<p>Importantly, <span class="math inline">x_4</span> is the only
non-basic variable in this constraint, and this is the <em>only</em>
constraint that <span class="math inline">x_4</span> shows up in (due to
the identity matrix structure in the basic variables). So each unit
increase in <span class="math inline">x_2</span> will require a 2-unit
<em>decrease</em> in <span class="math inline">x_4</span> to balance the
constraint. Since each variable (and so in particular, <span
class="math inline">x_4</span>) must stay non-negative, we can only
increase <span class="math inline">x_2</span> from 0 to 6 and still
remain feasible.</p>
<p>So we carry out this procedure with each constraint in eq. <a
href="#eq:simplexExampleMatrix1">5</a> (rows 2-4). <span
class="math inline">x_2</span> has a coefficient of 0 in the second row,
so this constraint will not be violated no matter how much we change
<span class="math inline">x_2</span>. Row four gives the equation <span
class="math inline">x_1 + 2x_2 + x_5 = 18</span>, so again a unit
increase in <span class="math inline">x_2</span> requires a 2-unit
decrease in <span class="math inline">x_5</span>. Since the right-hand
side is 18, we can only increase <span class="math inline">x_2</span> to
9 before <span class="math inline">x_5</span> will go negative.</p>
<p>Let’s summarize what we’ve done now: for each constraint, we’ve
compared the contribution of <span class="math inline">x_2</span> to the
contribution of the corresponding basic variable. We saw above that when
the coefficient on <span class="math inline">x_2</span> is zero for a
given constraint, then changing the value of <span
class="math inline">x_2</span> will not affect that constraint at all.
We didn’t have an example of this, but if the coefficient on <span
class="math inline">x_2</span> were negative then increasing <span
class="math inline">x_2</span> is counteracted by an <em>increase</em>
in the current basic variable. Variables must be non-negative, but there
is no <em>upper</em> bound, so we are free to increase a variable as
much as we want. Thus the only constraints that restrict <span
class="math inline">x_2</span> are the ones where the coefficient on
<span class="math inline">x_2</span> is strictly positive.</p>
<p>So the rows where the <span class="math inline">x_2</span>
coefficient is positive are where we need to worry about the current
basic variable going negative, and where we need to calculate how much
<span class="math inline">x_2</span> can increase before that happens.
You may or may not have noticed, but because of the identity matrix
structure in the basis, all we need to do for this calculation is divide
the right-hand side (rhs) value by the coefficient on <span
class="math inline">x_2</span> in each constraint! Thus our concern is
the following ratios:</p>
<p><span class="math display">
x_2\text{ column: }\begin{bmatrix}0 \\ 2 \\ 2\end{bmatrix}\
\text{ rhs: }\begin{bmatrix}4 \\ 12 \\ 18\end{bmatrix}\
\text{ ratio: }\begin{bmatrix}- \\ 12/2 \\ 18/2\end{bmatrix} =
\begin{bmatrix}- \\ 6 \\ 9\end{bmatrix}
</span></p>
<p>Then the variable leaving the basis should be the one in the
constraint that gives the smallest such ratio (we call this process the
<strong>minimum ratio test</strong>). Why? As we discussed above, the
ratio in each column is the bound on how much we can increase the
entering variable before the basic variable decreases to 0. So we must
take the minimum such increase in order to keep the entire system
feasible. In our case, the minimum ratio comes in the second constraint.
The basic variable included in that constraint is <span
class="math inline">x_4</span>, so we must choose <span
class="math inline">x_4</span> to leave the basis<a href="#fn32"
class="footnote-ref" id="fnref32"
role="doc-noteref"><sup>32</sup></a>.</p>
<h4>
Solve the new system
</h4>
<p>Now that we’ve identified the variables entering and exiting the
basis, what remains is to find the values of the variables at the new
solution. Since <span class="math inline">x_1</span> and <span
class="math inline">x_4</span> are non-basic, their values will be 0. To
find the other values, we’ll essentially do <a
href="https://en.wikipedia.org/wiki/Gaussian_elimination">Gaussian
elimination</a> on the matrix system eq. <a
href="#eq:simplexExampleMatrix1">5</a> to yield an identity matrix
structure over the columns corresponding to our basis.</p>
<p>Our basis variable swap came from the model’s second constraint,
which corresponds to row 3 in the matrix. This will be the “identity”
row for the entering variable <span class="math inline">x_2</span>, so
we’ll multiply that row by <span class="math inline">1/2</span> to get a
new matrix:</p>
<p><span class="math display">
\begin{bmatrix}
1 &amp; -3 &amp; -5 &amp; 0 &amp; 0   &amp; 0 \\
0 &amp; 1  &amp;  0 &amp; 1 &amp; 0   &amp; 0 \\
0 &amp; 0  &amp;  1 &amp; 0 &amp; 1/2 &amp; 0 \\
0 &amp; 3  &amp;  2 &amp; 0 &amp; 0   &amp; 1 \\
\end{bmatrix}
\begin{bmatrix}
Z \\ x_1 \\ x_2 \\ x_3 \\ x_4 \\ x_5
\end{bmatrix}
=
\begin{bmatrix}
0 \\ 4 \\ 6 \\ 18
\end{bmatrix}
</span></p>
<p>To complete the identity matrix structure, we must change all other
coefficients in the <span class="math inline">x_2</span> column to equal
zero. So we’ll do the following:</p>
<ul>
<li>Multiply the third row by 5 and add it to the first row.</li>
<li>Multiply the third row by -2 and add it to the fourth row.</li>
</ul>
<p>Our new matrix will have the identity structure we’re after:</p>
<p><span id="eq:simplexExampleMatrix2" class="eqnos"><span
class="math display">
\begin{bmatrix}
1 &amp; -3 &amp; 0 &amp; 0 &amp; 5/2 &amp; 0 \\
0 &amp; 1  &amp; 0 &amp; 1 &amp; 0   &amp; 0 \\
0 &amp; 0  &amp; 1 &amp; 0 &amp; 1/2 &amp; 0 \\
0 &amp; 3  &amp; 0 &amp; 0 &amp; -1  &amp; 1 \\
\end{bmatrix}
\begin{bmatrix}
Z \\ x_1 \\ x_2 \\ x_3 \\ x_4 \\ x_5
\end{bmatrix}
=
\begin{bmatrix}
30 \\ 4 \\ 6 \\ 6
\end{bmatrix}
</span><span class="eqnos-number">(6)</span></span></p>
<p>Lastly, as before, we can simply read the values of the objective and
the basic variables from the rhs of the system: <span
class="math inline">Z=30, x_3=4, x_2=6, x_5=6</span>.</p>
<h4>
Keep iterating
</h4>
<p>We’ve now completed initialization and the first iteration of the
method. So we continue iterating, starting from the optimality testing
phase. In this case, the non-basic variable <span
class="math inline">x_1</span> has a negative coefficient in the top row
of eq. <a href="#eq:simplexExampleMatrix2">6</a>, so we do not have on
optimal solution.</p>
<p>The other non-basic variable, <span class="math inline">x_4</span>,
has a positive coefficient in the top row. So <span
class="math inline">x_1</span> is our only candidate for entering the
basis. Now let’s set up our ratio test:</p>
<p><span class="math display">
x_1\text{ column: }\begin{bmatrix}1 \\ 0 \\ 3\end{bmatrix}\
\text{ rhs: }\begin{bmatrix}4 \\ 6 \\ 6\end{bmatrix}\
\text{ ratio: }\begin{bmatrix}4/1 \\ - \\ 6/3\end{bmatrix} =
\begin{bmatrix}4 \\ - \\ 2\end{bmatrix}
</span></p>
<p>Then at most we can increase <span class="math inline">x_1</span> to
2, as going any further will make <span class="math inline">x_5</span>
(the basic variable in the last constraint) negative. So we’ll replace
<span class="math inline">x_5</span> with <span
class="math inline">x_1</span> as the basic variable in the last
constraint. Using elimination to build our identity structure yields the
following matrix:</p>
<p><span class="math display">
\begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; 0 &amp;  3/2 &amp;    1 \\
0 &amp; 0 &amp; 0 &amp; 1 &amp;  1/3 &amp; -1/3 \\
0 &amp; 0 &amp; 1 &amp; 0 &amp;  1/2 &amp;    0 \\
0 &amp; 1 &amp; 0 &amp; 0 &amp; -1/3 &amp;  1/3 \\
\end{bmatrix}
\begin{bmatrix}
Z \\ x_1 \\ x_2 \\ x_3 \\ x_4 \\ x_5
\end{bmatrix}
=
\begin{bmatrix}
36 \\ 2 \\ 6 \\ 2
\end{bmatrix}
</span></p>
<p>Thus our new solution is <span class="math inline">x_1=2, x_2=6,
x_3=2, x_4=0</span>, and <span class="math inline">x_5=0</span><a
href="#fn33" class="footnote-ref" id="fnref33"
role="doc-noteref"><sup>33</sup></a>. Since the top row has all positive
coefficients, increasing these variables would only serve to decrease
the objective. So we’ve passed the optimality test, and can terminate
with the optimal solution!</p>
<h3 data-number="4.6.5" id="simplex-in-matrix-notation"><span
class="header-section-number">4.6.5</span> Simplex in matrix
notation</h3>
<p>Now that we have the mechanics down, let’s tidy up our presentation
of the simplex method by writing out the steps in matrix notation.
Recall that for simplex we need equality constraints and non-negative
variables, so our problem is formulated as in eq. <a
href="#eq:augmentedFormLpMatrix">4</a>. Additionally, we will assume
that the <span class="math inline">m\times n</span> matrix <span
class="math inline">A</span> is has rank <span
class="math inline">m</span> and is <em>non-singular</em>, so in
particular <span class="math inline">n\geq m</span> and there are no
<em>redundant</em> constraints (which would be any constraint that is a
linear combination of some of the others). The rank assumption can be
done without loss of generality, because any redundant system can be
reduced to non-redundant by removing constraints<a href="#fn34"
class="footnote-ref" id="fnref34"
role="doc-noteref"><sup>34</sup></a>.</p>
<p>At each step of the simplex method, the matrix calculations required
rely on the sub-matrix of <span class="math inline">\mathbf{A}</span>
corresponding to the basic variables. Let’s recall eq. <a
href="#eq:simplexExampleMatrix1">5</a>, the initial set of equations
defining our sample LP when we solved it in section <a
href="#sec:simplexExample">4.6.4</a>. In this case, our matrix <span
class="math inline">\mathbf{A}</span> is given by</p>
<p><span class="math display">
\mathbf{A}= \begin{bmatrix}
1  &amp;  0 &amp; 1 &amp; 0 &amp; 0 \\
0  &amp;  2 &amp; 0 &amp; 1 &amp; 0 \\
3  &amp;  2 &amp; 0 &amp; 0 &amp; 1 \\
\end{bmatrix}
</span></p>
<p>The sub-matrix we’re after at any given iteration, which we’ll call
<span class="math inline">\mathbf{B}</span> is the subset of columns
corresponding to our basic variables. Our initial basis in section <a
href="#sec:simplexExample">4.6.4</a> was <span
class="math inline">\{x_3, x_4, x_5\}</span>, and so the matrix of
interest in the first iteration was</p>
<p><span class="math display">
\mathbf{B}= \begin{bmatrix}
1 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 1 \\
\end{bmatrix}
</span>.</p>
<p>The vector of variables <span class="math inline">\mathbf{x}</span>
can similarly be segmented into the parts corresponding to basic
variables, which we’ll call <span
class="math inline">\mathbf{x}_B</span>, and non-basic variables <span
class="math inline">\mathbf{x}_N</span>. So for our example problem at
the first iteration we had:</p>
<p><span class="math display">
\mathbf{x}=\begin{bmatrix}x_1\\x_2\\x_3\\x_4\\x_5\end{bmatrix}\quad\mathbf{x}_B=\begin{bmatrix}x_3\\x_4\\x_5\end{bmatrix}\quad\mathbf{x}_N=\begin{bmatrix}x_1\\x_2\end{bmatrix}
</span></p>
<p>To solve the system of equations at any iteration, we applied
elementary row operations to create an identity matrix in the columns
corresponding to our basis. But since <span
class="math inline">\mathbf{B}</span> is non-singular, it has an inverse
<span class="math inline">\mathbf{B}^{-1}</span> such that <span
class="math inline">\mathbf{B}^{-1}\mathbf{B}=\mathbf{I}</span>, where
<span class="math inline">\mathbf{I}</span> is an identity matrix. So
really, all of our row operations amounted to pre-multiplying the system
of equations by <span class="math inline">\mathbf{B}^{-1}</span>.</p>
<p>Given this, watch what happens when we pre-multiply both sides of our
constraints by <span class="math inline">\mathbf{B}^{-1}</span>:</p>
<div class="mathSmall">
<p><span class="math display">
\begin{align*}
\mathbf{A}\mathbf{x}= \mathbf{b}
&amp; \Leftrightarrow \mathbf{B}^{-1}\mathbf{A}\mathbf{x}=
\mathbf{B}^{-1}\mathbf{b}&amp;&amp; \quad(\text{pre-mult by
}\mathbf{B}^{-1}) \\
&amp; \Leftrightarrow
\mathbf{B}^{-1}\mathbf{A}\begin{bmatrix}\mathbf{x}_B\\\mathbf{x}_N\end{bmatrix}
= \mathbf{B}^{-1}\mathbf{b}&amp;&amp; \quad(\text{partition }x\text{
into basic/non-basic}) \\
&amp; \Leftrightarrow
\mathbf{B}^{-1}\mathbf{A}\begin{bmatrix}\mathbf{x}_B\\\mathbf{0}\end{bmatrix}
= \mathbf{B}^{-1}\mathbf{b}&amp;&amp;
\quad(\mathbf{x}_N=\mathbf{0}\text{ in basic solutions}) \\
&amp; \Leftrightarrow \mathbf{B}^{-1}\mathbf{B}\mathbf{x}_B =
\mathbf{B}^{-1}\mathbf{b}&amp;&amp; \quad(\mathbf{x}_N=\mathbf{0}\text{
takes out other columns of }\mathbf{A}) \\
&amp; \Leftrightarrow \mathbf{I}\mathbf{x}_B =
\mathbf{B}^{-1}\mathbf{b}&amp;&amp; \quad(\text{definition of inverse})
\\
&amp; \Leftrightarrow \mathbf{x}_B = \mathbf{B}^{-1}\mathbf{b}&amp;&amp;
\quad(\text{definition of identity})
\end{align*}
</span></p>
</div>
<p>So getting the variable values at a basic solution is as simple as
taking <span class="math inline">\mathbf{x}_N=\mathbf{0}</span> and
<span class="math inline">\mathbf{x}_B=\mathbf{B}^{-1}\mathbf{b}</span>.
If we similarly partition the objective vector <span
class="math inline">\mathbf{c}</span> into <span
class="math inline">\mathbf{c}_B</span> (corresponding to the basic
variables) and <span class="math inline">\mathbf{c}_N</span> (non-basic
variables) then the objective value at that solution is:</p>
<p><span class="math display">
\begin{align*}
\mathbf{c}\mathbf{x}&amp; = \mathbf{c}_B\mathbf{x}_B +
\mathbf{c}_N\mathbf{x}_N &amp;&amp; \\
&amp; = \mathbf{c}_B\mathbf{x}_B &amp;&amp;
\quad(\mathbf{x}_N=\mathbf{0}) \\
&amp; = \mathbf{c}_B\mathbf{B}^{-1}\mathbf{b}&amp;&amp; \quad(\text{sub
above value for }\mathbf{x}_B) \\
\end{align*}
</span></p>
<p>So we know how to find the solution for any given basis, but what
about determining entering and exiting variables? In section <a
href="#sec:simplexExample">4.6.4</a> we used the information from the
objective (top) row of our problem matrix, so let’s re-introduce that
here. We can summarize all of our problem information in the following
matrix formulation:</p>
<p><span id="eq:simplexMatrixAllInfo" class="eqnos"><span
class="math display">
\begin{bmatrix}
1 &amp; -\mathbf{c}\\
\mathbf{0}&amp; \mathbf{A}
\end{bmatrix}
\begin{bmatrix}
Z \\ \mathbf{x}
\end{bmatrix}
=
\begin{bmatrix}
0 \\ \mathbf{b}
\end{bmatrix}
</span><span class="eqnos-number">(7)</span></span></p>
<p>where once again <span class="math inline">Z</span> is a “variable”
representing the objective value. Note that this matches exactly with
eq. <a href="#eq:simplexExampleMatrix1">5</a> from section <a
href="#sec:simplexExample">4.6.4</a>.</p>
<h4>
The magic matrix
</h4>
<p>We know from linear algebra that any sequence of elementary matrix
operations can be performed simultaneously via matrix multiplication.
All we did during the iterations section <a
href="#sec:simplexExample">4.6.4</a> was apply elementary row operations
to the original matrix, so if we can find the correct matrix, recovering
all the relevant information is as simple as multiplying by that matrix.
With that in mind, let me present to you the following matrix<a
href="#fn35" class="footnote-ref" id="fnref35"
role="doc-noteref"><sup>35</sup></a>.</p>
<p><span id="eq:magicMatrix" class="eqnos"><span class="math display">
\begin{bmatrix}1 &amp; \mathbf{c}_B\mathbf{B}^{-1}\\ \mathbf{0}&amp;
\mathbf{B}^{-1}\end{bmatrix}
</span><span class="eqnos-number">(8)</span></span></p>
<p>Watch what happens when we pre-multiply this on the right-hand side
of eq. <a href="#eq:simplexMatrixAllInfo">7</a>:</p>
<p><span class="math display">
\begin{bmatrix}1 &amp; \mathbf{c}_B\mathbf{B}^{-1}\\ \mathbf{0}&amp;
\mathbf{B}^{-1}\end{bmatrix}
\begin{bmatrix}
0 \\ \mathbf{b}
\end{bmatrix}
=
\begin{bmatrix}
\mathbf{c}_B\mathbf{B}^{-1}\mathbf{b}\\ \mathbf{B}^{-1}\mathbf{b}
\end{bmatrix}
</span></p>
<p>The top of the result is the objective value <span
class="math inline">Z</span> at the current basis solution, and the
bottom give the values of <span class="math inline">\mathbf{x}_B</span>.
So it looks like eq. <a href="#eq:magicMatrix">8</a> is precisely the
matrix we need to encapsulate all the operations we did during a simplex
iteration. Of course, any multiplication we apply on one side of an
equation must also be applied to the other side to keep the system
valid. So let’s apply pre-multiply eq. <a href="#eq:magicMatrix">8</a>
on the left-hand side of eq. <a href="#eq:simplexMatrixAllInfo">7</a> as
well:</p>
<p><span class="math display">
\begin{bmatrix}1 &amp; \mathbf{c}_B\mathbf{B}^{-1}\\ \mathbf{0}&amp;
\mathbf{B}^{-1}\end{bmatrix}
\begin{bmatrix}
1 &amp; -\mathbf{c}\\
\mathbf{0}&amp; \mathbf{A}
\end{bmatrix}
= \begin{bmatrix}1 &amp; \mathbf{c}_B\mathbf{B}^{-1}\mathbf{A}-
\mathbf{c}\\ \mathbf{0}&amp; \mathbf{B}^{-1}\mathbf{A}\end{bmatrix}
</span></p>
<p>So for any given basis, the information we require for the simplex
method is all present in the following system:</p>
<p><span id="eq:simplexMatrixGeneralized" class="eqnos"><span
class="math display">
\begin{bmatrix}1 &amp; \mathbf{c}_B\mathbf{B}^{-1}\mathbf{A}-
\mathbf{c}\\ \mathbf{0}&amp; \mathbf{B}^{-1}\mathbf{A}\end{bmatrix}
\begin{bmatrix}Z \\ \mathbf{x}\end{bmatrix}
=
\begin{bmatrix}
\mathbf{c}_B\mathbf{B}^{-1}\mathbf{b}\\ \mathbf{B}^{-1}\mathbf{b}
\end{bmatrix}
</span><span class="eqnos-number">(9)</span></span></p>
<p>The top row coefficients <span
class="math inline">\mathbf{c}_B\mathbf{B}^{-1}\mathbf{A}-
\mathbf{c}</span> are often called the <strong>reduced costs</strong> of
the variables at the current solution.</p>
<p>Maybe this looks a little messy when seeing it the first time, but
don’t let that scare you! Look at all the constituent elements of this
system. <span class="math inline">\mathbf{A}, \mathbf{b}</span>, and
<span class="math inline">\mathbf{c}</span> are all just
vectors/matrices from the problem definition. The only thing you need to
do from iteration to iteration is choose the basis, invert <span
class="math inline">\mathbf{B}</span> (which is just a sub-matrix of
<span class="math inline">\mathbf{A}</span>), then multiply!</p>
<p>To finish off this section, let’s use Python to verify that the
system we recover from eq. <a href="#eq:simplexMatrixGeneralized">9</a>
matches with what we got during the iterations in section <a
href="#sec:simplexExample">4.6.4</a>.</p>
<script src="https://gist.github.com/e5817bc5b1eb52dce2737969e0ee0c83.js"></script>
<h3 data-number="4.6.6"
id="presenting-finally-the-simplex-algorithm-mostly"><span
class="header-section-number">4.6.6</span> Presenting (finally) the
simplex algorithm (mostly)</h3>
<p>While we still have some edge cases and gotchas to discuss, we have
what we need to now succinctly specify the core of the simplex
algorithm. Remember, we assume any LP being solved by the simplex method
has been converted (by means of the techniques in section <a
href="#sec:lpForms">4.5</a>) to the equality-constrained form of eq. <a
href="#eq:augmentedFormLpMatrix">4</a>.</p>
<ul>
<li><em>Initialize</em>: Determine an initial BF solution (we’ll discuss
general methods for this in section <a
href="#sec:lpOtherConsiderations">4.6.7</a>).</li>
<li><em>Iterate</em>:
<ul>
<li><em>Test for optimality</em>: Examine the values of <span
class="math inline">\mathbf{c}_B\mathbf{B}^{-1}\mathbf{A}-
\mathbf{c}</span> (i.e. the reduced costs, from the top row of eq. <a
href="#eq:simplexMatrixGeneralized">9</a>) corresponding to the
non-basic variables. If all coefficients are non-negative, terminate
with the optimal solution. Otherwise, continue with the iteration.</li>
<li><em>Determine the entering basic variable</em>: Select some variable
whose coefficient in <span
class="math inline">\mathbf{c}_B\mathbf{B}^{-1}\mathbf{A}-
\mathbf{c}</span> is negative.</li>
<li><em>Determine the exiting basic variable</em>: Suppose the entering
variable from the last step corresponds to the <span
class="math inline">j</span>th column of the original constraint matrix
<span class="math inline">A</span>. Perform the <em>minimum ratio
test</em> from section <a href="#sec:simplexExample">4.6.4</a>, dividing
the entries of the vector <span
class="math inline">\mathbf{B}^{-1}\mathbf{b}</span> (the right-hand
side of the constraints portion of eq. <a
href="#eq:simplexMatrixGeneralized">9</a>) by the entries in the <span
class="math inline">j</span>th column of <span
class="math inline">\mathbf{B}^{-1}\mathbf{A}</span>. For the exiting
variable, select the basic variable corresponding to the row with the
smallest positive ratio.</li>
</ul></li>
</ul>
<p>And that’s it!</p>
<h3 data-number="4.6.7" id="sec:lpOtherConsiderations"><span
class="header-section-number">4.6.7</span> Other considerations</h3>
<p>Let’s now discuss some implementation details that add slight
complications to the simplex algorithm, and would need to be taken care
of in any LP solving software.</p>
<h4>
Determining the initial BF solution
</h4>
<p>In our sample problem, determining an initial BF solution was simple
because of the slack variables we added to convert the problem to
equality form. But this won’t always be possible. By way of example,
suppose in our sample LP eq. <a href="#eq:prototypeLp">1</a> the problem
requires plant 3 to operate at full capacity. Then the third constraint
becomes an equality constraint, <span class="math inline">3x_1 + 2x_2 =
18</span>. Once slack variables are added to the other constraints, we
have the following formulation:</p>
<p><span class="math display">
\begin{align*}
\text{max}&amp;&amp; 3x_1 + 5x_2 &amp; \\
\text{s.t.}&amp;&amp; x_1 + x_3 &amp; = \ \ 4 \\
&amp;&amp; 2x_2 + x_4 &amp; = 12 \\
&amp;&amp; 3x_1 + 2x_2 &amp; = 18 \\
&amp;&amp; x_1,x_2,x_3,x_4 &amp; \geq \ \ 0
\end{align*}
</span></p>
<p>There is no longer a nice identity matrix structure on which to base
our initial BF solution. In this case, a good trick is to add an extra,
so-called <strong>artificial variable</strong> to the formulation.
Additionally, we will add this variable to the objective function with a
<em>huge</em> negative coefficient denoted by <span
class="math inline">M</span>, a trick known as the <strong>Big M
method</strong>. For the above problem, the artificial variable
formulation will look like:</p>
<p><span class="math display">
\begin{align*}
\text{max}&amp;&amp; 3x_1 + 5x_2 - M\hat x_5&amp; \\
\text{s.t.}&amp;&amp; x_1 + x_3 &amp; = \ \ 4 \\
&amp;&amp; 2x_2 + x_4 &amp; = 12 \\
&amp;&amp; 3x_1 + 2x_2 + \hat x_5 &amp; = 18 \\
&amp;&amp; x_1,x_2,x_3,x_4,\hat x_5 &amp; \geq \ \ 0
\end{align*}
</span></p>
<p>Note that we require the artificial variable to be non-negative to
conform with eq. <a href="#eq:augmentedFormLpMatrix">4</a>, the form
required for simplex. It is further worth noting that the right-hand
side of the constraint needs to be non-negative to keep <span
class="math inline">\hat x_5\geq0</span> in the initial solution. This
is no big deal though, since if the right-hand side were negative we
could simply multiply both sides of the constraint by <span
class="math inline">-1</span> and use the resultant constraint in the
formulation instead.</p>
<p>What good will this do us? We can initialize simplex now with <span
class="math inline">x_3, x_4</span>, and <span class="math inline">\hat
x_5</span> as our original basis. Further, due to the massive penalty to
the objective for including <span class="math inline">\hat x_5</span> in
a solution, the artificial variable will eventually leave the basis if
possible. So we keep running simplex until either:</p>
<ul>
<li><span class="math inline">\hat x_5</span> drops out of the basis, at
which point we can remove it from the problem completely and continue
iterating simplex as usual.</li>
<li>We find an optimal solution to the artificial problem that includes
<span class="math inline">\hat x_5&gt;0</span>, in which case the
original problem was infeasible.</li>
</ul>
<p>Note that in this example we added only one artificial variable, but
it is possible that an artificial variable needs to be added for every
constraint. Either way the method is the same: make sure the right-hand
sides are non-negative, add the artificial variables, and keep iterating
through simplex until the artificial variables are gone.</p>
<h4>
Choosing the entering basic variable
</h4>
<p>We may choose the entering basic variable to be any non-basic
variable with a negative coefficient for <span
class="math inline">\mathbf{c}_B\mathbf{B}^{-1}\mathbf{A}-
\mathbf{c}</span>. If there are multiple qualifying non-basic variables,
a common rule-of-thumb is to select the variable whose coefficient has
the largest absolute value. This is not guaranteed to be a
<em>better</em> choice than any of the others. But the thinking is,
might as well try the variable that gives you the most bang for your
buck as far as objective value change.</p>
<p>But what if there is a tie for the largest absolute value among
negative coefficients? You can just pick arbitrarily. As we mentioned,
simplex doesn’t really care that the largest absolute value is selected
anyway. So no special tie-breaking rule is required here.</p>
<h4>
Tie for the exiting basic variable
</h4>
<p>We determine the exiting variable based on <em>minimum ratio
test</em>. But what if the minimum ratio is shared between multiple
basic variables? Unlike in the case of the entering basic variable,
there actually <em>is</em> something to worry about in this case.</p>
<p>Let’s recall what the minimum ratio test was calculating. In each
row, we were determining how much we could increase the value of the
entering variable before the corresponding basic variable becomes zero.
A tie in the minimum ratio test would mean that multiple of the current
basic variables would take on a value of 0 when the entering variable
joins the basis. Thus in the next basic solution, at least one basic
variable will have a value of 0. Such a BF solution is called a
<strong>degenerate</strong> solution, and the 0-valued basic variables
are called degenerate variables.</p>
<p>Degeneracy can cause issues for the simplex method. In particular, if
a degenerate basic variable is the exiting variable in a subsequent
simplex iteration, then the entering variable cannot increase in value
from zero without making the degenerate variable take a negative value.
So even with the basis change, the solution stayed the same from one
iteration to the next. Even worse, this could continue in a cycle such
that simplex never stops iterating!</p>
<p>Luckily these looping conditions are exceedingly rare in practical
problems. Furthermore, there are rules for selecting the exiting basic
variable that are guaranteed to avoid this infinite looping scenario
(see e.g. <span class="citation" data-cites="simplexPivotNoLoops">Bland
(<a href="#ref-simplexPivotNoLoops"
role="doc-biblioref">1977</a>)</span>), though we won’t cover them in
this course.</p>
<h4>
No exiting basic variable
</h4>
<p>Recall that during the minimum ratio test for determining the exiting
basic variable, we only consider ratios in the rows where the
coefficient on the entering variable is strictly positive. This is
because a 0 or negative coefficient would imply that the entering
variable could be increased arbitrarily without violating either the
corresponding constraint or non-negativity for the corresponding basic
variable. If <em>every</em> such coefficient were <span
class="math inline">\leq 0</span>, this would imply that the entire
system remains feasible no matter how much the entering variable is
increased.</p>
<p>Recall that we selected an entering variable whose inclusion would
improve the objective value. But if the entering variable can be
increased indefinitely, then also the objective can be increased
indefinitely, so our problem is unbounded. So if at any point the
simplex method comes to an iteration where the entering variable’s
coefficients are all <span class="math inline">\leq0</span>, we
terminate and declare the problem unbounded.</p>
<h3 data-number="4.6.8" id="the-revised-simplex-method"><span
class="header-section-number">4.6.8</span> The revised simplex
method</h3>
<p>We’ll end this section on the simplex method with a note on the
so-called <strong>revised simplex method</strong>. Recall that every
iteration of the simplex method requires us to find <span
class="math inline">\mathbf{B}^{-1}</span>, the inverse of the columns
of <span class="math inline">\mathbf{A}</span> corresponding to the
basis variables. In practice, doing this inversion can be
computationally expensive. But it is possible to cut down on the
computation time by applying a nice trick to derive <span
class="math inline">\mathbf{B}^{-1}</span> for the current iteration
from the inverted matrix from the previous iteration. We won’t bother
with the details here, but you can read about it in <span
class="citation" data-cites="classText">Hillier and Lieberman (<a
href="#ref-classText" role="doc-biblioref">2021</a>)</span>, section
5.4.</p>
<!-- {insertSection:sections/linear_programming/duality.md} -->
<!-- {insertSection:sections/integer_programming.md} -->
<h1 data-number="5" id="appendix"><span
class="header-section-number">5</span> Appendix</h1>
<h2 data-number="5.1" id="sec:symbols"><span
class="header-section-number">5.1</span> Special symbols</h2>
<ul>
<li><span class="math inline">\mathbb{R}</span>: The set of real
numbers, i.e. anything on the number line between (though not
including!) <span class="math inline">-\infty</span> and <span
class="math inline">\infty</span>.</li>
<li><span class="math inline">\mathbb{R}_+</span>: The set of
non-negative real numbers, i.e. anything in <span
class="math inline">\mathbb{R}</span> that is greater than or equal to
0.</li>
<li><span class="math inline">\mathbb{I}</span>: The set of integer
numbers, i.e. whole numbers from the set <span
class="math inline">\mathbb{R}</span>.</li>
<li><span class="math inline">\mathbb{I}_+</span>: The set of
non-negative integer numbers, i.e. anything in <span
class="math inline">\mathbb{I}</span> that is greater than or equal to
0.</li>
<li><span class="math inline">\{\cdots\}</span>: Set notation. Items
inside the curly brackets are the elements of the set, so <span
class="math inline">\{0,1\}</span> is the 2-element set consisting of
just the numbers 0 and 1.</li>
<li><span class="math inline">\in</span>: Set inclusion. When we write
<span class="math inline">x\in S</span>, we mean that <span
class="math inline">x</span> is an element of the set <span
class="math inline">S</span>. For example, we could write <span
class="math inline">\pi\in\mathbb{R}</span>, meaning the number <span
class="math inline">\pi</span> is a real number.</li>
<li><span class="math inline">\forall</span>: For all. We use this
symbol when we want to specify that something should be done for all
elements in some set. So if we’re writing out the constraints for some
model and we say <span class="math inline">x_j\geq 0\ \forall\ j\in\{1,
2, \cdots, n\}</span> we’re just saying that each of <span
class="math inline">x_1, x_2, \cdots, x_n</span> should be
non-negative.</li>
<li><span class="math inline">S^m</span>: The set of vectors with <span
class="math inline">m</span> elements, all of which are from some set
<span class="math inline">S</span>. For example, <span
class="math inline">\mathbb{R}^3</span> is the set of 3-element, real
number vectors. So we could say <span class="math display">
    \begin{bmatrix}1 \\ 2.64 \\ -3\end{bmatrix}\in\mathbb{R}^3.
</span></li>
<li><span class="math inline">S^{m\times n}</span>: The set of matrices
with <span class="math inline">m</span> rows and <span
class="math inline">n</span> columns, whose elements are from some set
<span class="math inline">S</span>. For example, <span
class="math inline">\mathbb{I}^{m\times n}</span> is the set of <span
class="math inline">m\times n</span> matrices whose entries are all
integers. So we could say <span class="math display">
\begin{bmatrix}4 &amp; 3 &amp; 9 &amp; 6\\ 0 &amp; 4 &amp; 8 &amp; 5\\ 7
&amp; 7 &amp; 2 &amp; 1\end{bmatrix} \in \mathbb{I}^{3\times 4}.
</span></li>
<li><span class="math inline">\mathbf{0}</span>: A matrix (or vector)
with all entries equal to 0 (the size of the matrix is usually clear by
context).</li>
<li><span class="math inline">\mathbf{I}</span>: A square matrix with
all entries equal to 0, except the diagonal where all entries equal 1
(the size of the matrix is usually clear by context). This looks like:
<span class="math display">\begin{bmatrix}
1 &amp; 0 &amp; \cdots &amp; 0 \\
0 &amp; 1 &amp; \cdots &amp; 0 \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
0 &amp; 0 &amp; \cdots &amp; 1 \\
\end{bmatrix}</span></li>
<li><span class="math inline">\Leftrightarrow</span>: If and only if. It
indicates the the statement to the left is logically equivalent to the
statement on the right, e.g. <span class="math inline">a &gt; b
\Leftrightarrow -a &lt; -b</span>.</li>
</ul>
<h2 data-number="5.2" id="sec:linearAlgebra"><span
class="header-section-number">5.2</span> Linear algebra review</h2>
<p>Linear algebra is the study of math involving matrices, vectors, and
linear transformations. A <strong>matrix</strong> (the basic object of
linear algebra) is a rectangular array of numbers. For example,</p>
<p><span class="math display">
\mathbf{A}=\begin{bmatrix} 2 &amp; 4 \\ 7 &amp; 0 \\ 6 &amp; 3
\end{bmatrix}
</span></p>
<p>is a <span class="math inline">3\times 2</span> matrix. A matrix is
said to be <strong>square</strong> if it has the same number of rows and
columns.</p>
<p>In these notes, we will usually denote matrices with boldface,
uppercase letters.</p>
<h3 data-number="5.2.1" id="sec:matrixMath"><span
class="header-section-number">5.2.1</span> Matrix math</h3>
<p>We say Matrices <span class="math inline">\mathbf{A}</span>, <span
class="math inline">\mathbf{B}</span> are <strong>equal</strong> if
<em>all</em> of their elements are equal. First off, that means <span
class="math inline">\mathbf{A}</span> and <span
class="math inline">\mathbf{B}</span> must have the same number of rows
<span class="math inline">m</span> and columns <span
class="math inline">n</span>. Additionally, if we write notate the
entries of the matrices like:</p>
<p><span id="eq:matrixDef" class="eqnos"><span class="math display">
\mathbf{A} = \begin{bmatrix}
a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \\
a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n} \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
a_{m1} &amp; a_{m2} &amp; \cdots &amp; a_{mn} \\
\end{bmatrix}
</span><span class="eqnos-number">(10)</span></span></p>
<p>and</p>
<p><span class="math display">
\mathbf{B} = \begin{bmatrix}
b_{11} &amp; b_{12} &amp; \cdots &amp; b_{1n} \\
b_{21} &amp; b_{22} &amp; \cdots &amp; b_{2n} \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
b_{m1} &amp; b_{m2} &amp; \cdots &amp; b_{mn} \\
\end{bmatrix}.
</span></p>
<p>Then we say <span class="math inline">\mathbf{A}=\mathbf{B}\ </span>
if and only if <span class="math inline">\ a_{11}=b_{11}</span>, <span
class="math inline">a_{12}=b_{12}</span>, … and so on.</p>
<p><strong>Addition</strong> is only defined for two matrices of the
same size. For two <span class="math inline">m\times n</span> matrices
<span class="math inline">\mathbf{A}</span> and <span
class="math inline">\mathbf{B}</span>, we have</p>
<p><span class="math display">
\mathbf{A} + \mathbf{B} = \begin{bmatrix}
a_{11} + b_{11} &amp; a_{12} + b_{12} &amp; \cdots &amp; a_{1n} + b_{1n}
\\
a_{21} + a_{21} &amp; a_{22} + a_{22} &amp; \cdots &amp; a_{2n} + a_{2n}
\\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
a_{m1} + a_{m1} &amp; a_{m2} + a_{m2} &amp; \cdots &amp; a_{mn} + a_{mn}
\\
\end{bmatrix}
</span></p>
<p>For matrices, <strong>multiplication</strong> <span
class="math inline">\mathbf{A}\mathbf{B}</span> is only defined when the
the second dimension of <span class="math inline">\mathbf{A}</span>
equals the first dimension of <span
class="math inline">\mathbf{B}</span>. So, if <span
class="math inline">\mathbf{A}</span> is an <span
class="math inline">m\times n</span> matrix (for some <span
class="math inline">m, n</span>), we need <span
class="math inline">B</span> to be an <span class="math inline">n\times
s</span> matrix (for some <span class="math inline">s</span>). In this
case, we define their product as the matrix <span
class="math inline">\mathbf{C}</span> having entries</p>
<p><span class="math display">
c_{ij} = \sum_{k=1}^n a_{ik}b_{kj}.
</span></p>
<p>Here is a small example to see it in action:</p>
<p><span class="math display">
\begin{align*}
\begin{bmatrix}0&amp;1\\2&amp;3\\4&amp;5\end{bmatrix}
\begin{bmatrix}6&amp;7\\8&amp;9\end{bmatrix}
&amp;=
\begin{bmatrix}
0\cdot6 + 1\cdot8 &amp; 0\cdot7 + 1\cdot9 \\
2\cdot6 + 3\cdot8 &amp; 2\cdot7 + 3\cdot9 \\
4\cdot6 + 5\cdot8 &amp; 4\cdot7 + 5\cdot9 \\
\end{bmatrix}\\
&amp;=
\begin{bmatrix}8&amp;9\\36&amp;41\\64&amp;73\end{bmatrix}
\end{align*}
</span></p>
<p>There is a simpler form of multiplication available between a matrix
<span class="math inline">\mathbf{A}</span> and a scalar (a single
number) <span class="math inline">s</span>, where each element of the
product is simply the corresponding element of <span
class="math inline">\mathbf{A}</span> multiplied by <span
class="math inline">s</span>, i.e.</p>
<p><span class="math display">
s\mathbf{A}= \begin{bmatrix}
sa_{11} &amp; sa_{12} &amp; \cdots &amp; sa_{1n} \\
sa_{21} &amp; sa_{22} &amp; \cdots &amp; sa_{2n} \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
sa_{m1} &amp; sa_{m2} &amp; \cdots &amp; sa_{mn} \\
\end{bmatrix}
</span></p>
<h3 data-number="5.2.2" id="properties-of-matrix-operations"><span
class="header-section-number">5.2.2</span> Properties of matrix
operations</h3>
<p>The above matrix operations satisfy the following properties:</p>
<ul>
<li>Associativity of addition:<span class="math display">(\mathbf{A}+
\mathbf{B}) + \mathbf{C} = \mathbf{A}+ (\mathbf{B} +
\mathbf{C})</span></li>
<li>Associativity of multiplication:<span
class="math display">\mathbf{A}(\mathbf{B}\mathbf{C}) =
(\mathbf{A}\mathbf{B})\mathbf{C}</span></li>
<li>Commutativity of addition:<span class="math display">\mathbf{A}+
\mathbf{B} = \mathbf{B} + \mathbf{A}</span></li>
<li>Distributivity:<span class="math display">\mathbf{A}(\mathbf{B} +
\mathbf{C}) = \mathbf{A}\mathbf{B} + \mathbf{A}\mathbf{C}</span></li>
</ul>
<p>You may notice that multiplication does not commute, i.e. <span
class="math inline">\mathbf{A}\mathbf{B} \neq
\mathbf{B}\mathbf{A}</span>. Indeed, in the general case where <span
class="math inline">\mathbf{A}</span> is an <span
class="math inline">m\times n</span> matrix and <span
class="math inline">\mathbf{B}</span> is an <span
class="math inline">n\times s</span> matrix, the product <span
class="math inline">\mathbf{B}\mathbf{A}</span> is not even defined if
<span class="math inline">m\neq s</span>. Even if <span
class="math inline">m=s</span> and the product is defined, the result
needs not be the same.</p>
<h3 data-number="5.2.3" id="special-matrices"><span
class="header-section-number">5.2.3</span> Special matrices</h3>
<p>A <strong>vector</strong> is a special type of matrix with either a
single column or a single row, e.g.</p>
<p><span class="math display">
\mathbf{x}=\begin{bmatrix} 1 \\ 9 \\ 3 \end{bmatrix}
</span></p>
<p>is a <strong>column vector</strong> and <span
class="math display">\mathbf{x}=\begin{bmatrix} 1 &amp; 9 &amp; 3
\end{bmatrix}</span> is a <strong>row vector</strong>. In these notes,
vectors will usually be denoted with with boldface, lowercase letters. A
convention in some texts, which we will not follow here, is for vectors
to be assumed as column vectors unless explicitly transposed. For these
notes, we will let context dictate whether a vector is a row vector or a
column vector (it is usually clear).</p>
<p>An <strong>identity matrix</strong>, denoted by <span
class="math inline">\mathbf{I}</span>, is a square vector whose elements
are all 0s expect for 1s along the diagonal, i.e.</p>
<p><span class="math display">
\mathbf{I}= \begin{bmatrix}
1 &amp; 0 &amp; \cdots &amp; 0 \\
0 &amp; 1 &amp; \cdots &amp; 0 \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
0 &amp; 0 &amp; \cdots &amp; 1 \\
\end{bmatrix}
</span></p>
<p>The main property of identity matrices is that multiplying another
(properly sizes) matrix does not alter it, i.e. we have</p>
<p><span class="math display">
\mathbf{I}\mathbf{A}= \mathbf{A},\quad \mathbf{A}\mathbf{I}= \mathbf{A}.
</span></p>
<p>Note that we usually don’t explicitly specify the size of <span
class="math inline">\mathbf{I}</span>, since it is usually clear from
the context.</p>
<p>The <strong>null matrix</strong> or <strong>zero matrix</strong>,
denoted by <span class="math inline">\mathbf{0}</span> is a matrix (or
vector) with all entries equal to 0. Again, we will usually not
explicitly specify its size since it will be clear from context. The
zero matrix satisfies:</p>
<p><span class="math display">
\mathbf{A}+ \mathbf{0}= \mathbf{A},\quad \mathbf{0}\mathbf{A}=
\mathbf{0},\quad \mathbf{A}\mathbf{0}= \mathbf{A}.
</span></p>
<p>Note that <span class="math inline">\mathbf{I}</span> and <span
class="math inline">\mathbf{0}</span> play roles in matrix operations
similar to the roles of 1 and 0 (respectively) in arithmetic.</p>
<h3 data-number="5.2.4" id="rank-and-inverse"><span
class="header-section-number">5.2.4</span> Rank and inverse</h3>
<p>A set of vectors <span class="math inline">\mathbf{x}_1,
\mathbf{x}_2, \dots, \mathbf{x}_m</span> is said to be <strong>linearly
dependent</strong> if there exists <span class="math inline">m</span>
numbers <span class="math inline">c_1, c_2, \dots, c_m</span>, some of
which are not zeros, such that</p>
<p><span class="math display">
c_1\mathbf{x}_1 + c_2\mathbf{x}_2 + \cdots + c_m\mathbf{x}_m =
\mathbf{0}.
</span></p>
<p>Otherwise, the vectors are said to be <strong>linearly
independent</strong>. For example, the vectors</p>
<p><span class="math display">
\mathbf{x}_1 = [1, 1, 1],\quad \mathbf{x}_2 = [0, 1, 1],\quad
\mathbf{x}_3 = [2, 5, 5],
</span></p>
<p>if we take <span class="math inline">c_1 = 2</span>, <span
class="math inline">c_2 = 3</span>, and <span class="math inline">c_3 =
-1</span> then we have</p>
<p><span class="math display">
\begin{align*}
2\mathbf{x}_1 + 3\mathbf{x}_2 - x_3 &amp; = [2, 2, 2] + [0, 3, 3] - [2,
5, 5]\\
                    &amp; = [0, 0, 0]
\end{align*}
</span></p>
<p>so the vectors are linearly dependent.</p>
<p>The <strong>rank</strong> of a set of vectors is the largest number
of linearly independent vectors that can be chosen from the space. So
e.g. the rank of <span class="math inline">\{\mathbf{x}_1, \mathbf{x}_2,
\mathbf{x}_3\}</span> from above is 2.</p>
<p>Matrices also have a notion of rank. The <strong>row rank</strong> of
a matrix is the rank of its set of row vectors, while the <strong>column
rank</strong> of the matrix is the rank of its set of column vectors. An
important result in linear algebra is that, for any matrix, the row rank
and column rank are the same. Thus we can talk about the
<strong>rank</strong> of a matrix, being equal to either the row rank or
the column rank.</p>
<p>Suppose <span class="math inline">\mathbf{A}</span> is an <span
class="math inline">n\times n</span> (square) matrix. We say <span
class="math inline">\mathbf{A}</span> is <strong>non-singular</strong>
if it has rank <span class="math inline">n</span>. Otherwise, if the
rank is less than <span class="math inline">n</span>, we way it is
<strong>singular</strong>. Importantly, if <span
class="math inline">\mathbf{A}</span> is non-singular, there is a unique
non-singular matrix <span class="math inline">\mathbf{A}^{-1}</span>
such that</p>
<p><span class="math display">
\mathbf{A}\mathbf{A}^{-1}= \mathbf{I}= \mathbf{A}^{-1}\mathbf{A}.
</span></p>
<p>We call the matrix <span class="math inline">\mathbf{A}^{-1}</span>
the <strong>inverse</strong> of <span
class="math inline">\mathbf{A}</span>. Furthermore, singular matrices do
not have inverses.</p>
<h3 data-number="5.2.5" id="systems-of-equations"><span
class="header-section-number">5.2.5</span> Systems of equations</h3>
<p>Matrices are great for concisely stating systems of linear equations,
linear equations in some set of variables you’d like to hold true
simultaneously. For example, the set of equations</p>
<p><span class="math display">
2x_1 + 3x_2 = 7\\
5x_1 - 4x_2 = 6
</span></p>
<p>can alternatively be stated as:</p>
<p><span class="math display">
\begin{bmatrix}
2 &amp; 3 \\
5 &amp; -4
\end{bmatrix}
\begin{bmatrix}
x_1 \\ x_2
\end{bmatrix}
=
\begin{bmatrix}
7 \\ 6
\end{bmatrix}
</span></p>
<h3 data-number="5.2.6" id="sec:elementaryRowOperations"><span
class="header-section-number">5.2.6</span> Elementary operations</h3>
<p>There are certain elementary operations one can perform on a system
of linear equations that don’t have an effect on the solution of the
system. I’ll state these operations in terms of rows, but similar
operations exist for columns as well:</p>
<ul>
<li>Interchange two rows: <span class="math display">
\begin{bmatrix}
2 &amp; 3 \\
5 &amp; -4
\end{bmatrix}
\begin{bmatrix}
x_1 \\ x_2
\end{bmatrix}
=
\begin{bmatrix}
7 \\ 6
\end{bmatrix}
\Leftrightarrow
\begin{bmatrix}
5 &amp; -4 \\
2 &amp; 3
\end{bmatrix}
\begin{bmatrix}
x_1 \\ x_2
\end{bmatrix}
=
\begin{bmatrix}
6 \\ 7
\end{bmatrix}
</span></li>
<li>Multiply a row by a non-zero number, e.g. multiplying the top row by
two: <span class="math display">
\begin{bmatrix}
2 &amp; 3 \\
5 &amp; -4
\end{bmatrix}
\begin{bmatrix}
x_1 \\ x_2
\end{bmatrix}
=
\begin{bmatrix}
7 \\ 6
\end{bmatrix}
\Leftrightarrow
\begin{bmatrix}
4 &amp; 6 \\
5 &amp; -4
\end{bmatrix}
\begin{bmatrix}
x_1 \\ x_2
\end{bmatrix}
=
\begin{bmatrix}
14 \\ 6
\end{bmatrix}
</span></li>
<li>Adding a multiple of one row to another row, e.g. multiplying the
first row by 2 and adding it to the second: <span class="math display">
\begin{bmatrix}
2 &amp; 3 \\
5 &amp; -4
\end{bmatrix}
\begin{bmatrix}
x_1 \\ x_2
\end{bmatrix}
=
\begin{bmatrix}
7 \\ 6
\end{bmatrix}
\Leftrightarrow
\begin{bmatrix}
2 &amp; 3 \\
9 &amp; 2
\end{bmatrix}
\begin{bmatrix}
x_1 \\ x_2
\end{bmatrix}
=
\begin{bmatrix}
7 \\ 20
\end{bmatrix}
</span></li>
</ul>
<h2 data-number="5.3" id="sec:appendixSelectedProofs"><span
class="header-section-number">5.3</span> Selected proofs</h2>
<p>This section contains proofs to selected statements in the main
text.</p>
<h1 id="References">References</h1>
<div id="refs" class="references csl-bib-body hanging-indent"
role="doc-bibliography">
<div id="ref-simplexPivotNoLoops" class="csl-entry"
role="doc-biblioentry">
Bland, Robert G. 1977. <span>“New Finite Pivoting Rules for the Simplex
Method.”</span> <em>Mathematics of Operations Research</em> 2 (2):
103–7. <a
href="http://www.jstor.org/stable/3689647">http://www.jstor.org/stable/3689647</a>.
</div>
<div id="ref-tspPursuit" class="csl-entry" role="doc-biblioentry">
Cook, William J. 2012. <em>In Pursuit of the Traveling Salesman:
Mathematics at the Limits of Computation</em>. Princeton University
Press. <a
href="http://www.jstor.org/stable/j.ctt7t8kc">http://www.jstor.org/stable/j.ctt7t8kc</a>.
</div>
<div id="ref-classText" class="csl-entry" role="doc-biblioentry">
Hillier, F. S., and G. J. Lieberman. 2021. <em>Introduction to
Operations Research</em>. McGraw-Hill Education. <a
href="https://books.google.com/books?id=gnhSzQEACAAJ">https://books.google.com/books?id=gnhSzQEACAAJ</a>.
</div>
<div id="ref-kleeMinty" class="csl-entry" role="doc-biblioentry">
Klee, Victor, and George J. Minty. 1970. <span>“HOW GOOD IS THE SIMPLEX
ALGORITHM.”</span> In. <a
href="https://api.semanticscholar.org/CorpusID:117965841">https://api.semanticscholar.org/CorpusID:117965841</a>.
</div>
<div id="ref-tspPic" class="csl-entry" role="doc-biblioentry">
<span>“Waterloo TSP.”</span> n.d. <a
href="https://www.math.uwaterloo.ca/tsp/"
class="uri">https://www.math.uwaterloo.ca/tsp/</a>.
</div>
</div>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>The most recent version of this textbook is the 11th
edition, which came out in 2021. But much of the content quoted here
comes from the 10th edition from 2015. Nothing about the course will
require you to have a certain edition, or any book at all. But I think
it’s a very useful reference.<a href="#fnref1" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>The pedant in me wants to point out that this word
“optimal” is horribly misused in conversation fairly regularly, in the
form of the misguided phrase “more optimal”. As I mentioned, “optimal”
really just means “best”, and “best” is not on a sliding scale; either
you have the best answer or you don’t. One choice can’t be “more best”
than another, just as one solution can’t be “more optimal” than another.
I think I’m fighting a losing battle on this, but maybe for the sake of
this course we can all agree to never put the words “more” and “optimal”
next to each other? Thanks.<a href="#fnref2" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>There’s a neat book all about the TSP, <span
class="citation" data-cites="tspPursuit">Cook (<a href="#ref-tspPursuit"
role="doc-biblioref">2012</a>)</span>, written by a great professor that
I took a course from while getting my PhD. It’s more popularly focused
than technical, so it’s a surprisingly smooth read. Highly
recommended!<a href="#fnref3" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>You can tell from the image that this map is pretty old.
<a href="https://www.math.uwaterloo.ca/tsp/usa50/">The site from which
it came</a> tells a neat story about how this instance was solved, by
hand, way back in 1954! There are some other interesting bits there too,
well worth a read in my opinion.<a href="#fnref4" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>If you <em>are</em> looking for a deep dive, I’d suggest
checking out the other classes in our Masters of Operations Research
program.<a href="#fnref5" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p>It’s not exactly like Jupyter, but the same in spirit.
Also, don’t worry if you don’t know about Jupyter or coding notebooks
yet.<a href="#fnref6" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn7"><p>This shouldn’t be a huge hurdle. If you don’t have one
already you can always create a burner account for the sake of the
class.<a href="#fnref7" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn8"><p>You can check out <a
href="https://www.python.org/downloads/">Python’s downloads page</a> or
go with <a href="https://www.anaconda.com/">Anaconda</a> for an expanded
built-in toolset.<a href="#fnref8" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn9"><p>I’m listing lots of Google Cloud products because that’s
the cloud platform I’ve used most, but the other big providers have
similar offerings.<a href="#fnref9" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn10"><p>You might look at this and think “that just means <span
class="math inline">x_2 \leq 6</span>.” You would be correct, and it
would be completely valid to use that constraint instead.<a
href="#fnref10" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn11"><p>The “s.t.” is an abbreviation for “subject to” and is
used in formulations leading into the constraints section.<a
href="#fnref11" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn12"><p>So long as we’re talking about real numbers, of course.
Something like <span class="math inline">x_1=\text{blue}</span>, <span
class="math inline">x_2=\text{elephant}</span> is just nonsense and
isn’t a solution to our problem.<a href="#fnref12" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn13"><p>The smallest value if we have a minimization problem,
or the largest value for a maximization problem.<a href="#fnref13"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn14"><p>I couldn’t think of a good way to do this with touch
events, so this part doesn’t work as well on a mobile device. Sorry.<a
href="#fnref14" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn15"><p>Actually, my little widget here is not perfect.
Depending how small of a decimal you add, you may get it to tell you
there are optimal solutions at a slightly higher objective value. This
is due to choosing a precision that this setup really can’t handle. It
is worth mentioning that even the most sophisticated solvers can have
issues with rounding errors and numerical stability, but they’re
generally very good. As long as you are careful with your formulations
you usually won’t run into issues.<a href="#fnref15"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn16"><p>Truth be told, this isn’t a rigorous proof of
optimality, at least in the strict sense of mathematical proofs. But the
solution methods we’ll study later do give such proofs.<a
href="#fnref16" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn17"><p>In most practical applications, infeasiblity is a good
indicator that you modeled something incorrectly. Like in this example,
it doesn’t make sense that we could make arbitrarily many of some
product. So if you find a problem you’re working on is infeasible, it’s
a good idea to double-check your formulation.<a href="#fnref17"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn18"><p>There are similar packages available in other popular
programming languages as well.<a href="#fnref18" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn19"><p>Most come with limited licenses for noncommercial uses,
and also offer free unrestricted licenses for students and academics.<a
href="#fnref19" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn20"><p>A quick example: <span class="math inline">x \leq
10</span> means the exact same thing as <span class="math inline">-x
\geq -10</span>.<a href="#fnref20" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn21"><p>You can think of <span class="math inline">y_j</span>
as the “positive part” and <span class="math inline">z_j</span> as the
“negative part” of <span class="math inline">x_j</span>. Note that we
haven’t done anything to enforce that only one of <span
class="math inline">y_j</span> and <span class="math inline">z_j</span>
are nonzero at a time. So for example if some solution to the original
formulation had <span class="math inline">x_j=2</span> then in the new
formulation we could have <span class="math inline">y_j=2</span> and
<span class="math inline">z_j=0</span>, or we could just as easily have
something like <span class="math inline">y_j=12, z_j=10</span> or <span
class="math inline">y_j=106.7, z_j=104.7</span>.<a href="#fnref21"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn22"><p>I’m not mentioning a lot of people by name in these
notes, but I couldn’t skip Dantzig. Mostly I wanted to bring up this
famous story: A student comes late to class one day, sees two problems
written on the board, and assumes they are the day’s assigned homework.
The problems are more difficult than usual, but he solves them. When he
turns them in, the professor is elated - these weren’t homework problems
at all, but rather famous unsolved problems in the field! You can find
several versions of this story out there, citing several different
people as the supposed student. Turns out <a
href="https://www.snopes.com/fact-check/the-unsolvable-math-problem/#6oJOtz9WKFQUHhbw.99">this
actually happened, and the student was Dantzig</a>.<a href="#fnref22"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn23"><p>There’s a neat story, quoting from <span
class="citation" data-cites="tspPursuit">Cook (<a href="#ref-tspPursuit"
role="doc-biblioref">2012</a>)</span>, in <a
href="https://punkrockor.com/2014/04/29/happiness-is-assuming-the-world-is-linear/">this
blog post</a> (yes, OR blogs are a thing). It’s specifically about
Dantzig first introducing the simplex method during a talk in 1948, and
more generally about understanding your assumptions 😀.<a
href="#fnref23" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn24"><p>Interestingly, several other linear programming
algorithms have been devised whose theoretical properties seem to
suggest they would be more efficient. But in practice that hasn’t been
the case. Simplex continues to be the best algorithm in practice for the
widest array of problems.<a href="#fnref24" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn25"><p>There are corner-point infeasible solutions as well,
which sit at intersections outside the feasible region<a href="#fnref25"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn26"><p>I’m used to calling them vertices, but the textbook
tends to call them corner-point solutions, which I like as a more
helpful, descriptive term. I’ll try to stick to corner-point solution
for the notes, but I expect to slip up a few times, especially during
lectures.<a href="#fnref26" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn27"><p>For those that are not aware, a
<strong>theorem</strong> is a mathematical statement that has been
proven to be true, based on some set of standard axioms. Anything I cite
as a theorem in these notes, you can be confident it holds true, even if
we don’t work through a rigorous proof.<a href="#fnref27"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn28"><p>At least not generally - for common variants of the
simplex method, there exist examples where every CPF solution is visited
during execution (<span class="citation" data-cites="kleeMinty">(<a
href="#ref-kleeMinty" role="doc-biblioref">Klee and Minty
1970</a>)</span> is the first, most famous example). But this isn’t
usually an issue in practice.<a href="#fnref28" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn29"><p>This is really the key takeaway from our whole
discussion in this section, and if this is the only thing you remember
about the simplex method 10 years from now I’ll still be satisfied. This
is the key insight, you can always re-learn the details later.<a
href="#fnref29" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn30"><p>The greek capital letter <span
class="math inline">\Delta</span> is commonly used to denote an amount
of change, and in these context is often read as “change in.”<a
href="#fnref30" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn31"><p>Note that having the highest per-unit change doesn’t
necessarily make it the “best” choice in any particular way. It may be
that choosing a different (but still improving) direction will mean that
we finish the algorithm faster. But in general we can’t tell beforehand,
so we often just choose the direction with the highest change as
convenient rule-of-thumb.<a href="#fnref31" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn32"><p>It is also possible to have a tie in the minimum ratio
test. This is another special case that we’ll cover later.<a
href="#fnref32" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn33"><p>Now might be a good time to check out the simplex
visualization in section <a href="#sec:simplexVisualized">4.6.2</a> and
see if you understand the interpretation of the slack variable values in
the solutions we’ve found.<a href="#fnref33" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn34"><p>Note also that if you came to the equality-constrained
problem (<span
class="math inline">\mathbf{A}\mathbf{x}=\mathbf{b}</span>) via a
transformation from the inequality form (<span
class="math inline">\mathbf{A}\mathbf{x}\leq\mathbf{b}</span>) by adding
slack variables, the slack variables themselves guarantee full row
rank.<a href="#fnref34" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn35"><p>Sorry to just present this to you as if it’s a mystical
gift from the gods. We could have totally derived it ourselves, but I
didn’t think it was worth the class time.<a href="#fnref35"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
<script>
    printerFunc = () => {
        header = document.getElementsByClassName('navbar')[0];
        footer = document.getElementsByTagName('footer')[0];
        header.style.visibility = 'hidden';
        footer.style.visibility = 'hidden';
        window.print();
        setTimeout(() => {})
    }
    window.onafterprint = function(){
        header.style.visibility = 'visible';
        footer.style.visibility = 'visible';
    }
</script>
</div>
<div id="classModeDiv"></div>
<footer>
    <div style="width:3rem"></div>
    <small>&copy; Copyright 2023, Jeffrey Pavelka</small>
    <div style='cursor:pointer;margin:0 1rem' onclick="printerFunc()">&#128438;</div>
</footer>
</body>
</html>
